[{"filePath":"/Users/yogi/agent-rpg-project/.claude/helpers/github-safe.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/integration/bundle-analyzer.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/integration/performance-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/integration/performance-provider.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1757,1760],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1757,1760],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2025,2028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2025,2028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2134,2137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2134,2137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":197,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":197,"endColumn":38}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance monitoring provider for React app\nimport { createContext, useContext, useEffect, useState, ReactNode, useCallback } from 'react';\nimport { performanceMonitor } from '../monitoring/performance-monitor';\nimport { webVitalsDashboard, WebVitalsMetric } from '../monitoring/web-vitals';\nimport { performanceReportGenerator, DetailedPerformanceReport } from '../reports/performance-report-generator';\n\ninterface PerformanceContextType {\n  isMonitoring: boolean;\n  webVitals: WebVitalsMetric[];\n  performanceScore: number;\n  startMonitoring: () => void;\n  stopMonitoring: () => void;\n  generateReport: () => Promise<DetailedPerformanceReport>;\n  clearMetrics: () => void;\n}\n\nconst PerformanceContext = createContext<PerformanceContextType | null>(null);\n\ninterface PerformanceProviderProps {\n  children: ReactNode;\n  enableInProduction?: boolean;\n}\n\nexport function PerformanceProvider({ \n  children, \n  enableInProduction = false\n}: PerformanceProviderProps) {\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [webVitals, setWebVitals] = useState<WebVitalsMetric[]>([]);\n  const [performanceScore, setPerformanceScore] = useState(100);\n\n  const startMonitoring = useCallback(() => {\n    if (isMonitoring) return;\n    \n    setIsMonitoring(true);\n    \n    // Subscribe to web vitals updates\n    const unsubscribe = webVitalsDashboard.subscribe((metric) => {\n      setWebVitals(prev => {\n        const filtered = prev.filter(m => m.name !== metric.name);\n        return [...filtered, metric];\n      });\n    });\n\n    // Update performance score periodically\n    const scoreInterval = setInterval(() => {\n      setPerformanceScore(webVitalsDashboard.getPerformanceScore());\n    }, 5000);\n\n    // Store cleanup functions\n    (window as any).__performanceCleanup = () => {\n      unsubscribe();\n      clearInterval(scoreInterval);\n    };\n  }, [isMonitoring]);\n\n  const stopMonitoring = useCallback(() => {\n    if (!isMonitoring) return;\n    \n    setIsMonitoring(false);\n    \n    const cleanup = (window as any).__performanceCleanup;\n    if (typeof cleanup === 'function') {\n      cleanup();\n      delete (window as any).__performanceCleanup;\n    }\n  }, [isMonitoring]);\n\n  useEffect(() => {\n    // Only enable monitoring in development or if explicitly enabled in production\n    if (process.env.NODE_ENV === 'development' || enableInProduction) {\n      startMonitoring();\n    }\n\n    return () => {\n      stopMonitoring();\n    };\n  }, [enableInProduction, startMonitoring, stopMonitoring]);\n\n  const generateReport = async (): Promise<DetailedPerformanceReport> => {\n    return await performanceReportGenerator.generateComprehensiveReport();\n  };\n\n  const clearMetrics = () => {\n    performanceMonitor.clearMetrics();\n    setWebVitals([]);\n    setPerformanceScore(100);\n  };\n\n  const contextValue: PerformanceContextType = {\n    isMonitoring,\n    webVitals,\n    performanceScore,\n    startMonitoring,\n    stopMonitoring,\n    generateReport,\n    clearMetrics\n  };\n\n  return (\n    <PerformanceContext.Provider value={contextValue}>\n      {children}\n      {/* Development performance overlay */}\n      {process.env.NODE_ENV === 'development' && isMonitoring && (\n        <PerformanceOverlay />\n      )}\n    </PerformanceContext.Provider>\n  );\n}\n\n// Development overlay for real-time performance monitoring\nfunction PerformanceOverlay() {\n  const { webVitals, performanceScore } = usePerformanceContext();\n  const [isExpanded, setIsExpanded] = useState(false);\n\n  const latestMetrics = performanceMonitor.getPerformanceReport();\n\n  return (\n    <div className=\"fixed top-4 right-4 z-50\">\n      <div \n        className={`bg-black/80 backdrop-blur border border-slate-600 rounded-lg transition-all ${\n          isExpanded ? 'w-80 h-auto' : 'w-16 h-16'\n        }`}\n      >\n        <button\n          onClick={() => setIsExpanded(!isExpanded)}\n          className=\"w-full h-16 flex items-center justify-center text-white hover:bg-white/10 rounded-lg\"\n          aria-label={isExpanded ? 'Collapse performance overlay' : 'Expand performance overlay'}\n        >\n          {isExpanded ? 'üìä' : '‚ö°'}\n        </button>\n        \n        {isExpanded && (\n          <div className=\"p-4 pt-0\">\n            <div className=\"text-white font-semibold mb-2\">Performance</div>\n            \n            {/* Performance Score */}\n            <div className=\"mb-3\">\n              <div className={`text-lg font-bold ${\n                performanceScore >= 80 ? 'text-green-400' :\n                performanceScore >= 60 ? 'text-yellow-400' : 'text-red-400'\n              }`}>\n                Score: {Math.round(performanceScore)}\n              </div>\n            </div>\n            \n            {/* Key Metrics */}\n            <div className=\"space-y-1 text-xs\">\n              {webVitals.slice(0, 3).map(vital => (\n                <div key={vital.name} className=\"flex justify-between\">\n                  <span className=\"text-slate-300\">{vital.name}:</span>\n                  <span className={\n                    vital.rating === 'good' ? 'text-green-400' :\n                    vital.rating === 'needs-improvement' ? 'text-yellow-400' : 'text-red-400'\n                  }>\n                    {vital.value.toFixed(0)}ms\n                  </span>\n                </div>\n              ))}\n              \n              {latestMetrics.current && (\n                <>\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-slate-300\">Render:</span>\n                    <span className={\n                      latestMetrics.current.renderTime < 16 ? 'text-green-400' : 'text-yellow-400'\n                    }>\n                      {latestMetrics.current.renderTime.toFixed(1)}ms\n                    </span>\n                  </div>\n                  <div className=\"flex justify-between\">\n                    <span className=\"text-slate-300\">Memory:</span>\n                    <span className=\"text-blue-400\">\n                      {(latestMetrics.current.heapUsed / 1024 / 1024).toFixed(1)}MB\n                    </span>\n                  </div>\n                </>\n              )}\n            </div>\n            \n            {/* Warnings */}\n            {latestMetrics.warnings.length > 0 && (\n              <div className=\"mt-2 p-2 bg-red-500/20 border border-red-500/50 rounded text-xs\">\n                <div className=\"text-red-400 font-semibold\">Issues:</div>\n                {latestMetrics.warnings.slice(0, 2).map((warning, i) => (\n                  <div key={i} className=\"text-red-300\">{warning.metric}</div>\n                ))}\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport function usePerformanceContext() {\n  const context = useContext(PerformanceContext);\n  if (!context) {\n    throw new Error('usePerformanceContext must be used within PerformanceProvider');\n  }\n  return context;\n}\n\nexport default PerformanceProvider;","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/integration/webpack-bundle-analyzer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/monitoring/performance-dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/monitoring/performance-monitor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2483,2486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2483,2486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance monitoring system for Agent Company RPG\n// Tracks render times, memory usage, component performance, and bottlenecks\n\nexport interface PerformanceMetric {\n  timestamp: number;\n  renderTime: number;\n  heapUsed: number;\n  heapTotal: number;\n  external: number;\n  componentCount: number;\n  requestCount?: number;\n  totalTransferSize?: number;\n}\n\nexport interface PerformanceWarning {\n  timestamp: number;\n  metric: string;\n  current: number;\n  budget: number;\n  severity: 'low' | 'medium' | 'high';\n}\n\nexport interface ComponentTiming {\n  component: string;\n  renderTime: number;\n  renderCount: number;\n  averageRenderTime: number;\n  lastRender: number;\n}\n\nexport interface PerformanceReport {\n  current: PerformanceMetric | null;\n  history: PerformanceMetric[];\n  warnings: PerformanceWarning[];\n  componentTimings: ComponentTiming[];\n  summary: {\n    averageRenderTime: number;\n    peakMemoryUsage: number;\n    totalWarnings: number;\n    slowComponents: string[];\n  };\n}\n\ninterface MemoryInfo {\n  usedJSHeapSize?: number;\n  totalJSHeapSize?: number;\n  jsHeapSizeLimit?: number;\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetric[] = [];\n  private warnings: PerformanceWarning[] = [];\n  private componentTimings: Map<string, ComponentTiming> = new Map();\n  private isMonitoring = false;\n  private monitoringInterval: number | null = null;\n  private maxHistorySize = 100;\n  \n  // Performance budgets (in milliseconds)\n  private budgets = {\n    renderTime: 16, // 60fps\n    componentRender: 8, // Individual component budget\n    memoryGrowth: 50 * 1024 * 1024, // 50MB memory growth warning\n  };\n\n  startMonitoring(interval = 1000): void {\n    if (this.isMonitoring) return;\n    \n    this.isMonitoring = true;\n    console.log('üöÄ Performance monitoring started');\n    \n    // Initial metric collection\n    this.collectMetrics();\n    \n    // Start periodic monitoring\n    this.monitoringInterval = window.setInterval(() => {\n      this.collectMetrics();\n    }, interval);\n  }\n\n  stopMonitoring(): void {\n    if (!this.isMonitoring) return;\n    \n    this.isMonitoring = false;\n    \n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n    \n    console.log('üõë Performance monitoring stopped');\n  }\n\n  collectMetrics(): PerformanceMetric {\n    const renderStartTime = performance.now();\n    \n    // Get memory information with type safety\n    const memInfo: MemoryInfo = (performance as any).memory || {\n      usedJSHeapSize: 0,\n      totalJSHeapSize: 0,\n      jsHeapSizeLimit: 0\n    };\n    \n    // Calculate render time (approximate)\n    const renderTime = performance.now() - renderStartTime;\n    \n    const metric: PerformanceMetric = {\n      timestamp: Date.now(),\n      renderTime,\n      heapUsed: memInfo.usedJSHeapSize || 0,\n      heapTotal: memInfo.totalJSHeapSize || 0,\n      external: memInfo.jsHeapSizeLimit || 0,\n      componentCount: this.componentTimings.size,\n      requestCount: this.getNetworkMetrics().requestCount,\n      totalTransferSize: this.getNetworkMetrics().totalTransferSize\n    };\n    \n    // Add to metrics history\n    this.metrics.push(metric);\n    \n    // Maintain history size\n    if (this.metrics.length > this.maxHistorySize) {\n      this.metrics.shift();\n    }\n    \n    // Check for performance issues\n    this.checkPerformanceBudgets(metric);\n    \n    return metric;\n  }\n\n  recordComponentTiming(componentName: string, renderTime: number): void {\n    const existing = this.componentTimings.get(componentName);\n    \n    if (existing) {\n      existing.renderCount++;\n      existing.renderTime += renderTime;\n      existing.averageRenderTime = existing.renderTime / existing.renderCount;\n      existing.lastRender = Date.now();\n    } else {\n      this.componentTimings.set(componentName, {\n        component: componentName,\n        renderTime,\n        renderCount: 1,\n        averageRenderTime: renderTime,\n        lastRender: Date.now()\n      });\n    }\n    \n    // Check component performance budget\n    if (renderTime > this.budgets.componentRender) {\n      this.logWarning(\n        `${componentName} render time`,\n        renderTime,\n        this.budgets.componentRender,\n        'medium'\n      );\n    }\n  }\n\n  recordMetric(name: string, value: number, tags: Record<string, string> = {}): void {\n    // Store custom metrics for analysis\n    if (process.env.NODE_ENV === 'development') {\n      console.debug(`üìä ${name}: ${value.toFixed(2)}ms`, tags);\n    }\n    \n    // Check if this is a concerning metric\n    if (name.includes('render') && value > 32) {\n      this.logWarning(`Custom metric: ${name}`, value, 32, 'medium');\n    }\n  }\n\n  logWarning(metric: string, current: number, budget: number, severity: PerformanceWarning['severity'] = 'medium'): void {\n    const warning: PerformanceWarning = {\n      timestamp: Date.now(),\n      metric,\n      current,\n      budget,\n      severity\n    };\n    \n    this.warnings.push(warning);\n    \n    // Maintain warnings history\n    if (this.warnings.length > 50) {\n      this.warnings.shift();\n    }\n    \n    // Log to console in development\n    if (process.env.NODE_ENV === 'development') {\n      const emoji = severity === 'high' ? 'üö®' : severity === 'medium' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';\n      console.warn(\n        `${emoji} Performance Warning: ${metric} - ${current.toFixed(1)} > ${budget} (${severity})`\n      );\n    }\n  }\n\n  private checkPerformanceBudgets(metric: PerformanceMetric): void {\n    // Check render time budget\n    if (metric.renderTime > this.budgets.renderTime) {\n      this.logWarning(\n        'Frame render time',\n        metric.renderTime,\n        this.budgets.renderTime,\n        'high'\n      );\n    }\n    \n    // Check memory growth\n    if (this.metrics.length > 1) {\n      const previousMetric = this.metrics[this.metrics.length - 2];\n      const memoryGrowth = metric.heapUsed - previousMetric.heapUsed;\n      \n      if (memoryGrowth > this.budgets.memoryGrowth) {\n        this.logWarning(\n          'Memory growth',\n          memoryGrowth,\n          this.budgets.memoryGrowth,\n          'medium'\n        );\n      }\n    }\n  }\n\n  private getNetworkMetrics(): { requestCount: number; totalTransferSize: number } {\n    if (!('getEntriesByType' in performance)) {\n      return { requestCount: 0, totalTransferSize: 0 };\n    }\n    \n    const entries = performance.getEntriesByType('resource') as PerformanceResourceTiming[];\n    \n    return {\n      requestCount: entries.length,\n      totalTransferSize: entries.reduce((total, entry) => total + (entry.transferSize || 0), 0)\n    };\n  }\n\n  getPerformanceReport(): PerformanceReport {\n    const current = this.metrics.length > 0 ? this.metrics[this.metrics.length - 1] : null;\n    \n    // Calculate summary statistics\n    const renderTimes = this.metrics.map(m => m.renderTime);\n    const memoryUsages = this.metrics.map(m => m.heapUsed);\n    \n    const averageRenderTime = renderTimes.length > 0 \n      ? renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length \n      : 0;\n      \n    const peakMemoryUsage = memoryUsages.length > 0 \n      ? Math.max(...memoryUsages) \n      : 0;\n    \n    // Find slow components\n    const slowComponents = Array.from(this.componentTimings.values())\n      .filter(timing => timing.averageRenderTime > this.budgets.componentRender)\n      .map(timing => timing.component);\n    \n    return {\n      current,\n      history: [...this.metrics],\n      warnings: [...this.warnings],\n      componentTimings: Array.from(this.componentTimings.values()),\n      summary: {\n        averageRenderTime,\n        peakMemoryUsage,\n        totalWarnings: this.warnings.length,\n        slowComponents\n      }\n    };\n  }\n\n  clearMetrics(): void {\n    this.metrics = [];\n    this.warnings = [];\n    this.componentTimings.clear();\n    console.log('üóëÔ∏è Performance metrics cleared');\n  }\n\n  // Utility method to get current performance snapshot\n  getCurrentSnapshot(): {\n    renderTime: number;\n    memoryUsage: number;\n    componentCount: number;\n    warningCount: number;\n  } {\n    const current = this.metrics[this.metrics.length - 1];\n    return {\n      renderTime: current?.renderTime || 0,\n      memoryUsage: current?.heapUsed || 0,\n      componentCount: this.componentTimings.size,\n      warningCount: this.warnings.length\n    };\n  }\n\n  // Export data for external analysis\n  exportData(): {\n    metrics: PerformanceMetric[];\n    warnings: PerformanceWarning[];\n    componentTimings: ComponentTiming[];\n    timestamp: string;\n  } {\n    return {\n      metrics: [...this.metrics],\n      warnings: [...this.warnings],\n      componentTimings: Array.from(this.componentTimings.values()),\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  // Set custom performance budgets\n  setBudgets(budgets: Partial<typeof this.budgets>): void {\n    this.budgets = { ...this.budgets, ...budgets };\n    console.log('üìã Performance budgets updated:', this.budgets);\n  }\n\n  // Get performance grade based on metrics\n  getPerformanceGrade(): { score: number; grade: string; issues: string[] } {\n    let score = 100;\n    const issues: string[] = [];\n    \n    // Deduct points for warnings\n    const highWarnings = this.warnings.filter(w => w.severity === 'high').length;\n    const mediumWarnings = this.warnings.filter(w => w.severity === 'medium').length;\n    \n    score -= highWarnings * 15;\n    score -= mediumWarnings * 5;\n    \n    if (highWarnings > 0) issues.push(`${highWarnings} critical performance issues`);\n    if (mediumWarnings > 3) issues.push(`${mediumWarnings} performance warnings`);\n    \n    // Deduct points for slow average render time\n    const report = this.getPerformanceReport();\n    if (report.summary.averageRenderTime > this.budgets.renderTime) {\n      score -= 20;\n      issues.push('Slow average render time');\n    }\n    \n    // Deduct points for slow components\n    if (report.summary.slowComponents.length > 0) {\n      score -= report.summary.slowComponents.length * 10;\n      issues.push(`${report.summary.slowComponents.length} slow components`);\n    }\n    \n    score = Math.max(0, score);\n    \n    let grade = 'A';\n    if (score < 90) grade = 'B';\n    if (score < 80) grade = 'C';\n    if (score < 70) grade = 'D';\n    if (score < 60) grade = 'F';\n    \n    return { score, grade, issues };\n  }\n}\n\n// Export singleton instance\nexport const performanceMonitor = new PerformanceMonitor();\n\n// Auto-start monitoring in development\nif (process.env.NODE_ENV === 'development' && typeof window !== 'undefined') {\n  // Small delay to avoid startup performance impact\n  setTimeout(() => {\n    performanceMonitor.startMonitoring();\n  }, 1000);\n}\n\nexport default performanceMonitor;","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/monitoring/web-vitals.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3608,3611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3608,3611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3697,3700],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3697,3700],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Core Web Vitals monitoring implementation\n// Based on Google's web-vitals library patterns\n\nexport interface WebVitalsMetric {\n  name: 'FCP' | 'LCP' | 'FID' | 'CLS' | 'TTFB' | 'INP';\n  value: number;\n  rating: 'good' | 'needs-improvement' | 'poor';\n  delta: number;\n  id: string;\n  timestamp: number;\n}\n\nexport type WebVitalsCallback = (metric: WebVitalsMetric) => void;\n\n// Thresholds based on Google's Core Web Vitals\nconst THRESHOLDS = {\n  FCP: [1800, 3000], // [good, needs-improvement] - poor is above needs-improvement\n  LCP: [2500, 4000],\n  FID: [100, 300],\n  CLS: [0.1, 0.25],\n  TTFB: [800, 1800],\n  INP: [200, 500]\n};\n\nfunction getRating(value: number, thresholds: number[]): 'good' | 'needs-improvement' | 'poor' {\n  if (value <= thresholds[0]) return 'good';\n  if (value <= thresholds[1]) return 'needs-improvement';\n  return 'poor';\n}\n\nlet fcpReported = false;\nlet lcpReported = false;\n\nexport function onFCP(callback: WebVitalsCallback) {\n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      if (entry.name === 'first-contentful-paint' && !fcpReported) {\n        fcpReported = true;\n        callback({\n          name: 'FCP',\n          value: entry.startTime,\n          rating: getRating(entry.startTime, THRESHOLDS.FCP),\n          delta: entry.startTime,\n          id: generateUniqueId(),\n          timestamp: Date.now()\n        });\n      }\n    }\n  });\n  \n  try {\n    observer.observe({ entryTypes: ['paint'] });\n  } catch {\n    console.warn('FCP observation not supported');\n  }\n}\n\nexport function onLCP(callback: WebVitalsCallback) {\n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      if (!lcpReported) {\n        lcpReported = true;\n        callback({\n          name: 'LCP',\n          value: entry.startTime,\n          rating: getRating(entry.startTime, THRESHOLDS.LCP),\n          delta: entry.startTime,\n          id: generateUniqueId(),\n          timestamp: Date.now()\n        });\n      }\n    }\n  });\n  \n  try {\n    observer.observe({ entryTypes: ['largest-contentful-paint'] });\n  } catch {\n    console.warn('LCP observation not supported');\n  }\n}\n\nexport function onFID(callback: WebVitalsCallback) {\n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      const fidEntry = entry as PerformanceEventTiming;\n      const value = fidEntry.processingStart - fidEntry.startTime;\n      \n      callback({\n        name: 'FID',\n        value,\n        rating: getRating(value, THRESHOLDS.FID),\n        delta: value,\n        id: generateUniqueId(),\n        timestamp: Date.now()\n      });\n    }\n  });\n  \n  try {\n    observer.observe({ entryTypes: ['first-input'] });\n  } catch {\n    console.warn('FID observation not supported');\n  }\n}\n\nexport function onCLS(callback: WebVitalsCallback) {\n  let clsValue = 0;\n  let sessionValue = 0;\n  let sessionEntries: unknown[] = [];\n  \n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      const layoutShiftEntry = entry as PerformanceEntry & { hadRecentInput: boolean; value: number; startTime: number };\n      \n      if (!layoutShiftEntry.hadRecentInput) {\n        const firstSessionEntry = sessionEntries[0];\n        const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n        \n        // If the entry occurred less than 1 second after the previous entry and\n        // less than 5 seconds after the first entry in the session, include it\n        if (sessionValue &&\n            layoutShiftEntry.startTime - (lastSessionEntry as any)?.startTime < 1000 &&\n            layoutShiftEntry.startTime - (firstSessionEntry as any)?.startTime < 5000) {\n          sessionValue += layoutShiftEntry.value;\n          sessionEntries.push(layoutShiftEntry);\n        } else {\n          sessionValue = layoutShiftEntry.value;\n          sessionEntries = [layoutShiftEntry];\n        }\n        \n        if (sessionValue > clsValue) {\n          clsValue = sessionValue;\n          callback({\n            name: 'CLS',\n            value: clsValue,\n            rating: getRating(clsValue, THRESHOLDS.CLS),\n            delta: layoutShiftEntry.value,\n            id: generateUniqueId(),\n            timestamp: Date.now()\n          });\n        }\n      }\n    }\n  });\n  \n  try {\n    observer.observe({ entryTypes: ['layout-shift'] });\n  } catch {\n    console.warn('CLS observation not supported');\n  }\n}\n\nexport function onTTFB(callback: WebVitalsCallback) {\n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      const navEntry = entry as PerformanceNavigationTiming;\n      const value = navEntry.responseStart - navEntry.requestStart;\n      \n      callback({\n        name: 'TTFB',\n        value,\n        rating: getRating(value, THRESHOLDS.TTFB),\n        delta: value,\n        id: generateUniqueId(),\n        timestamp: Date.now()\n      });\n    }\n  });\n  \n  try {\n    observer.observe({ entryTypes: ['navigation'] });\n  } catch {\n    console.warn('TTFB observation not supported');\n  }\n}\n\n// Interaction to Next Paint (INP) - newer metric\nexport function onINP(callback: WebVitalsCallback) {\n  const interactionMap = new Map();\n  \n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      const eventEntry = entry as PerformanceEntry & { interactionId?: number; duration?: number };\n      \n      if (eventEntry.interactionId) {\n        const interaction = interactionMap.get(eventEntry.interactionId) || [];\n        interaction.push(eventEntry);\n        interactionMap.set(eventEntry.interactionId, interaction);\n        \n        // Calculate INP when interaction is complete\n        if (interaction.length >= 3 || eventEntry.duration > 0) {\n          const duration = Math.max(...interaction.map((e: PerformanceEntry & { duration?: number }) => e.duration || 0));\n          \n          callback({\n            name: 'INP',\n            value: duration,\n            rating: getRating(duration, THRESHOLDS.INP),\n            delta: duration,\n            id: generateUniqueId(),\n            timestamp: Date.now()\n          });\n        }\n      }\n    }\n  });\n  \n  try {\n    observer.observe({ entryTypes: ['event'] });\n  } catch {\n    console.warn('INP observation not supported');\n  }\n}\n\nexport function getCoreWebVitals(callback: WebVitalsCallback) {\n  onFCP(callback);\n  onLCP(callback);\n  onFID(callback);\n  onCLS(callback);\n  onTTFB(callback);\n  onINP(callback);\n}\n\nfunction generateUniqueId(): string {\n  return Math.random().toString(36).substr(2, 9);\n}\n\n// Real-time performance dashboard data\nexport class WebVitalsDashboard {\n  private metrics: WebVitalsMetric[] = [];\n  private callbacks: WebVitalsCallback[] = [];\n\n  constructor() {\n    this.initializeCollection();\n  }\n\n  private initializeCollection() {\n    const callback: WebVitalsCallback = (metric) => {\n      this.metrics.push(metric);\n      this.callbacks.forEach(cb => cb(metric));\n      \n      // Keep only last 100 metrics\n      if (this.metrics.length > 100) {\n        this.metrics = this.metrics.slice(-100);\n      }\n    };\n\n    getCoreWebVitals(callback);\n  }\n\n  subscribe(callback: WebVitalsCallback) {\n    this.callbacks.push(callback);\n    return () => {\n      const index = this.callbacks.indexOf(callback);\n      if (index > -1) {\n        this.callbacks.splice(index, 1);\n      }\n    };\n  }\n\n  getMetrics() {\n    return [...this.metrics];\n  }\n\n  getLatestMetrics() {\n    const latest: { [key: string]: WebVitalsMetric } = {};\n    \n    for (const metric of this.metrics) {\n      if (!latest[metric.name] || metric.timestamp > latest[metric.name].timestamp) {\n        latest[metric.name] = metric;\n      }\n    }\n    \n    return Object.values(latest);\n  }\n\n  getPerformanceScore(): number {\n    const latest = this.getLatestMetrics();\n    if (latest.length === 0) return 100;\n    \n    const scores = latest.map(metric => {\n      switch (metric.rating) {\n        case 'good': return 100;\n        case 'needs-improvement': return 50;\n        case 'poor': return 0;\n      }\n    });\n    \n    return scores.reduce((sum: number, score: number) => sum + score, 0) / scores.length;\n  }\n}\n\nexport const webVitalsDashboard = new WebVitalsDashboard();\nexport default webVitalsDashboard;","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/optimization/react-optimizations.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":261,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":261,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// React performance optimizations for Agent Company RPG\nimport React, { memo, useMemo, useCallback, lazy } from 'react';\nimport { Agent } from '../../src/types/agent';\n\n// Lazy loaded components for code splitting\nexport const LazyAgentSheet = lazy(() => import('../../src/components/AgentSheet'));\nexport const LazyQuestBoard = lazy(() => import('../../src/components/QuestBoard'));\n\n// Memoized agent card component\nexport const OptimizedAgentCard = memo(({ \n  agent, \n  onSelect, \n  renderXPBar \n}: {\n  agent: Agent;\n  isLeveling: boolean;\n  onSelect: (agent: Agent) => void;\n  renderXPBar: (current: number, toNext: number, level: number, agent?: Agent) => React.ReactNode;\n}) => {\n  const handleSelect = useCallback(() => {\n    onSelect(agent);\n  }, [agent, onSelect]);\n\n  const specializations = useMemo(() => \n    agent.specializations.slice(0, 3), \n    [agent.specializations]\n  );\n\n  const recentActivity = useMemo(() => \n    agent.realtimeActivity[0]?.action || 'No recent activity',\n    [agent.realtimeActivity]\n  );\n\n  return (\n    <div \n      data-agent-id={agent.id}\n      className=\"agent-card p-4 space-y-3 transition-all duration-300\"\n      onClick={handleSelect}\n    >\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center space-x-3\">\n          <span className=\"text-2xl\">{agent.avatar}</span>\n          <div>\n            <h3 className=\"font-semibold text-lg\">{agent.name}</h3>\n            <p className=\"text-sm text-purple-300\">{agent.class}</p>\n          </div>\n        </div>\n        <div className=\"text-right\">\n          <div className=\"text-sm text-slate-400\">Level {agent.level}</div>\n          <div className=\"text-xs text-green-400\">{agent.currentMission}</div>\n        </div>\n      </div>\n      \n      <div className=\"relative\">\n        {renderXPBar(agent.xp, agent.xpToNext, agent.level, agent)}\n      </div>\n      \n      <AgentStats stats={agent.stats} />\n      \n      <div className=\"flex flex-wrap gap-1\">\n        {specializations.map((spec, idx) => (\n          <span key={idx} className=\"text-xs bg-slate-700 px-2 py-1 rounded\">\n            {spec}\n          </span>\n        ))}\n        {agent.specializations.length > 3 && (\n          <span className=\"text-xs text-slate-400\">+{agent.specializations.length - 3} more</span>\n        )}\n      </div>\n      \n      <div className=\"border-t border-slate-600 pt-2\">\n        <div className=\"text-xs text-slate-400 mb-1\">Recent Activity:</div>\n        <div className=\"text-xs text-cyan-300\">{recentActivity}</div>\n      </div>\n    </div>\n  );\n});\n\n// Memoized stats component\nconst AgentStats = memo(({ stats }: { stats: Agent['stats'] }) => (\n  <div className=\"grid grid-cols-5 gap-2 text-xs\">\n    <StatItem value={stats.intelligence} label=\"INT\" color=\"text-blue-400\" />\n    <StatItem value={stats.creativity} label=\"CRE\" color=\"text-purple-400\" />\n    <StatItem value={stats.reliability} label=\"REL\" color=\"text-green-400\" />\n    <StatItem value={stats.speed} label=\"SPD\" color=\"text-yellow-400\" />\n    <StatItem value={stats.leadership} label=\"LEA\" color=\"text-red-400\" />\n  </div>\n));\n\n// Micro-optimized stat item\nconst StatItem = memo(({ value, label, color }: { value: number; label: string; color: string }) => (\n  <div className=\"text-center\">\n    <div className={`${color} font-semibold`}>{value}</div>\n    <div className=\"text-slate-400\">{label}</div>\n  </div>\n));\n\n// Virtualized agent list for large datasets\nexport const VirtualizedAgentList = memo(({ \n  agents, \n  renderItem,\n  itemHeight = 200,\n  containerHeight = 600\n}: {\n  agents: Agent[];\n  renderItem: (agent: Agent, index: number) => React.ReactNode;\n  itemHeight?: number;\n  containerHeight?: number;\n}) => {\n  const [scrollTop, setScrollTop] = React.useState(0);\n  \n  const visibleRange = useMemo(() => {\n    const start = Math.floor(scrollTop / itemHeight);\n    const end = Math.min(start + Math.ceil(containerHeight / itemHeight) + 1, agents.length);\n    return { start, end };\n  }, [scrollTop, itemHeight, containerHeight, agents.length]);\n\n  const visibleItems = useMemo(() => \n    agents.slice(visibleRange.start, visibleRange.end),\n    [agents, visibleRange]\n  );\n\n  const totalHeight = agents.length * itemHeight;\n\n  return (\n    <div \n      style={{ height: containerHeight, overflow: 'auto' }}\n      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        <div style={{ transform: `translateY(${visibleRange.start * itemHeight}px)` }}>\n          {visibleItems.map((agent, index) => \n            renderItem(agent, visibleRange.start + index)\n          )}\n        </div>\n      </div>\n    </div>\n  );\n});\n\n// Optimized XP bar with memoization\nexport const OptimizedXPBar = memo(({ \n  current, \n  toNext, \n  level, \n  isLeveling = false \n}: {\n  current: number;\n  toNext: number;\n  level: number;\n  isLeveling?: boolean;\n}) => {\n  const percentage = useMemo(() => \n    (current / toNext) * 100, \n    [current, toNext]\n  );\n\n  const style = useMemo(() => ({\n    width: `${percentage}%`,\n    '--xp-percentage': `${percentage}%`,\n    '--xp-start': '0%',\n    '--xp-final': `${percentage}%`,\n    animation: isLeveling ? 'xpBarMultiLevel 2s ease-out' : undefined,\n    transition: !isLeveling ? 'width 0.5s ease-out' : undefined\n  } as React.CSSProperties), [percentage, isLeveling]);\n\n  return (\n    <div className=\"xp-bar relative\">\n      <div \n        className={`xp-progress ${isLeveling ? 'xp-multi-level' : ''}`}\n        style={style}\n      />\n      <div className=\"absolute inset-0 flex items-center justify-center text-xs font-medium\">\n        Level {level} ‚Ä¢ {current}/{toNext} XP\n      </div>\n    </div>\n  );\n});\n\n// Debounced search component\nexport const DebouncedSearch = memo(({ \n  onSearch, \n  placeholder = \"Search...\",\n  delay = 300\n}: {\n  onSearch: (query: string) => void;\n  placeholder?: string;\n  delay?: number;\n}) => {\n  const [query, setQuery] = React.useState('');\n  const timeoutRef = React.useRef<NodeJS.Timeout | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    \n    timeoutRef.current = setTimeout(() => {\n      onSearch(query);\n    }, delay);\n\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [query, delay, onSearch]);\n\n  return (\n    <input\n      type=\"text\"\n      placeholder={placeholder}\n      value={query}\n      onChange={(e) => setQuery(e.target.value)}\n      className=\"px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg text-white text-sm\"\n    />\n  );\n});\n\n// Performance-optimized loading states\nexport const LoadingSpinner = memo(() => (\n  <div className=\"flex items-center justify-center p-8\">\n    <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-purple-400\" />\n  </div>\n));\n\nexport const ErrorBoundary = class extends React.Component<\n  { children: React.ReactNode; fallback?: React.ReactNode },\n  { hasError: boolean; error?: Error }\n> {\n  constructor(props: { children: React.ReactNode; fallback?: React.ReactNode }) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    console.error('Performance boundary caught error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n        <div className=\"p-4 bg-red-500/20 border border-red-500/50 rounded-lg\">\n          <h3 className=\"text-red-400 font-semibold mb-2\">Something went wrong</h3>\n          <p className=\"text-sm text-red-300\">\n            {this.state.error?.message || 'An unexpected error occurred'}\n          </p>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n};\n\n// Higher-order component for performance tracking\nexport function withPerformanceTracking<P extends object>(\n  Component: React.ComponentType<P>,\n  componentName: string\n) {\n  return memo((props: P) => {\n    const renderStart = performance.now();\n    \n    React.useEffect(() => {\n      const renderEnd = performance.now();\n      const renderTime = renderEnd - renderStart;\n      \n      if (renderTime > 16) { // Log slow renders\n        console.warn(`Slow render detected in ${componentName}: ${renderTime.toFixed(2)}ms`);\n      }\n    });\n\n    return <Component {...props} />;\n  });\n}\n\n// Optimized grid layout for responsive performance\nexport const ResponsiveGrid = memo(({ \n  children, \n  minItemWidth = 300,\n  gap = 16 \n}: {\n  children: React.ReactNode;\n  minItemWidth?: number;\n  gap?: number;\n}) => {\n  const [columns, setColumns] = React.useState(1);\n  \n  React.useEffect(() => {\n    const updateColumns = () => {\n      const containerWidth = window.innerWidth - 48; // Account for padding\n      const maxColumns = Math.floor((containerWidth + gap) / (minItemWidth + gap));\n      setColumns(Math.max(1, maxColumns));\n    };\n    \n    updateColumns();\n    window.addEventListener('resize', updateColumns);\n    return () => window.removeEventListener('resize', updateColumns);\n  }, [minItemWidth, gap]);\n\n  return (\n    <div \n      style={{\n        display: 'grid',\n        gridTemplateColumns: `repeat(${columns}, 1fr)`,\n        gap: `${gap}px`\n      }}\n    >\n      {children}\n    </div>\n  );\n});\n\nexport default {\n  OptimizedAgentCard,\n  OptimizedXPBar,\n  VirtualizedAgentList,\n  DebouncedSearch,\n  LoadingSpinner,\n  ErrorBoundary,\n  withPerformanceTracking,\n  ResponsiveGrid,\n  LazyAgentSheet,\n  LazyQuestBoard\n};","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/optimization/xp-calculator-optimized.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":6,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[277,280],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[277,280],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Optimized XP calculation system with memoization and performance improvements\nimport { Agent, AgentStats } from '../../src/types/agent';\nimport { Quest } from '../../src/types/quest';\n\n// Memoization cache for expensive calculations\nconst calculationCache = new Map<string, any>();\nconst CACHE_SIZE_LIMIT = 1000;\n\n// Performance-optimized cache management\nfunction setCache(key: string, value: unknown) {\n  if (calculationCache.size >= CACHE_SIZE_LIMIT) {\n    // Remove oldest 20% of entries\n    const keysToDelete = Array.from(calculationCache.keys()).slice(0, Math.floor(CACHE_SIZE_LIMIT * 0.2));\n    keysToDelete.forEach(k => calculationCache.delete(k));\n  }\n  calculationCache.set(key, value);\n}\n\nfunction getCache(key: string) {\n  return calculationCache.get(key);\n}\n\n// Pre-computed level thresholds for performance\nconst LEVEL_THRESHOLDS = new Map<number, number>();\nconst BASE_XP_TO_NEXT_LEVEL = 100;\nconst LEVEL_XP_MULTIPLIER = 1.5;\n\n// Pre-compute first 100 levels on module load\nfor (let level = 1; level <= 100; level++) {\n  LEVEL_THRESHOLDS.set(level, Math.floor(BASE_XP_TO_NEXT_LEVEL * Math.pow(LEVEL_XP_MULTIPLIER, level - 1)));\n}\n\n// Optimized difficulty multipliers as a frozen object\nconst DIFFICULTY_MULTIPLIERS = {\n  Tutorial: 0.5,\n  Easy: 1.0,\n  Medium: 1.5,\n  Hard: 2.0,\n  Expert: 3.0,\n  Legendary: 5.0\n} as const;\n\n// Pre-computed class bonuses\nconst CLASS_XP_BONUSES = {\n  'Code Master': { Investigation: 1.2, Creation: 1.3 },\n  'Data Sage': { Investigation: 1.3, Exploration: 1.2 },\n  'Creative Bard': { Creation: 1.3, Diplomacy: 1.2 },\n  'Rapid Scout': { Exploration: 1.3, Combat: 1.2 },\n  'System Architect': { Creation: 1.2, Training: 1.3 },\n  'Bug Hunter': { Investigation: 1.3, Combat: 1.3 },\n  'Documentation Wizard': { Creation: 1.2, Diplomacy: 1.3 }\n} as const;\n\n// Ultra-fast level threshold lookup\nexport function calculateXpToNextLevel(level: number): number {\n  const cached = LEVEL_THRESHOLDS.get(level);\n  if (cached !== undefined) return cached;\n  \n  // Fallback for levels > 100\n  const result = Math.floor(BASE_XP_TO_NEXT_LEVEL * Math.pow(LEVEL_XP_MULTIPLIER, level - 1));\n  LEVEL_THRESHOLDS.set(level, result);\n  return result;\n}\n\n// Optimized total XP calculation with memoization\nexport function calculateTotalXpForLevel(targetLevel: number): number {\n  const cacheKey = `totalXp_${targetLevel}`;\n  const cached = getCache(cacheKey);\n  if (cached !== undefined) return cached;\n  \n  let totalXp = 0;\n  for (let level = 1; level < targetLevel; level++) {\n    totalXp += calculateXpToNextLevel(level);\n  }\n  \n  setCache(cacheKey, totalXp);\n  return totalXp;\n}\n\n// Highly optimized level calculation using binary search\nexport function calculateLevelFromXp(totalXp: number): { level: number; currentLevelXp: number; xpToNext: number } {\n  const cacheKey = `levelFromXp_${totalXp}`;\n  const cached = getCache(cacheKey);\n  if (cached !== undefined) return cached;\n  \n  // Binary search for level (much faster than linear)\n  let low = 1, high = 100;\n  let level = 1;\n  \n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    const xpRequired = calculateTotalXpForLevel(mid);\n    \n    if (totalXp >= xpRequired) {\n      level = mid;\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  \n  const currentLevelXp = totalXp - calculateTotalXpForLevel(level);\n  const xpToNext = calculateXpToNextLevel(level);\n  \n  const result = { level, currentLevelXp, xpToNext };\n  setCache(cacheKey, result);\n  return result;\n}\n\n// Batch XP calculation for multiple agents\nexport function batchCalculateXpRewards(\n  questAgentPairs: Array<{ quest: Quest; agent: Agent; completionData?: {\n    completionTime?: number;\n    optionalObjectivesCompleted?: number;\n    teamPerformanceBonus?: number;\n  } }>\n): Array<{ agentId: number; xpReward: number; calculationTime: number }> {\n  const startTime = performance.now();\n  \n  const results = questAgentPairs.map(({ quest, agent, completionData }) => {\n    const calcStart = performance.now();\n    const xpReward = calculateQuestXpRewardOptimized(quest, agent, completionData);\n    const calcTime = performance.now() - calcStart;\n    \n    return {\n      agentId: agent.id,\n      xpReward,\n      calculationTime: calcTime\n    };\n  });\n  \n  const totalTime = performance.now() - startTime;\n  console.log(`Batch XP calculation completed in ${totalTime.toFixed(2)}ms for ${questAgentPairs.length} pairs`);\n  \n  return results;\n}\n\n// Optimized quest XP reward calculation\nexport function calculateQuestXpRewardOptimized(\n  quest: Quest,\n  agent: Agent,\n  completionData?: {\n    completionTime?: number;\n    optionalObjectivesCompleted?: number;\n    teamPerformanceBonus?: number;\n  }\n): number {\n  const cacheKey = `questXp_${quest.id}_${agent.id}_${JSON.stringify(completionData)}`;\n  const cached = getCache(cacheKey);\n  if (cached !== undefined) return cached;\n  \n  let xpReward = quest.rewards.xp;\n  \n  // Optimized difficulty multiplier lookup\n  xpReward *= DIFFICULTY_MULTIPLIERS[quest.difficulty as keyof typeof DIFFICULTY_MULTIPLIERS] ?? 1.0;\n  \n  // Optimized class bonus lookup\n  const classBonus = CLASS_XP_BONUSES[agent.class as keyof typeof CLASS_XP_BONUSES];\n  if (classBonus) {\n    const categoryBonus = classBonus[quest.category as keyof typeof classBonus];\n    if (categoryBonus) {\n      xpReward *= categoryBonus;\n    }\n  }\n  \n  // Time bonus calculations (if provided)\n  if (completionData?.completionTime && quest.timeLimit) {\n    const timeRatio = completionData.completionTime / quest.timeLimit;\n    if (timeRatio < 0.5) {\n      xpReward *= 1.5;\n    } else if (timeRatio < 0.75) {\n      xpReward *= 1.25;\n    } else if (timeRatio < 1.0) {\n      xpReward *= 1.1;\n    }\n  }\n  \n  // Optional objectives bonus\n  if (completionData?.optionalObjectivesCompleted) {\n    const totalOptional = quest.objectives.filter(obj => obj.optional).length;\n    if (totalOptional > 0) {\n      const optionalRatio = completionData.optionalObjectivesCompleted / totalOptional;\n      xpReward += (quest.bonusRewards?.xp || 0) * optionalRatio;\n    }\n  }\n  \n  // Team synergy bonus\n  if (quest.assignedAgents.length > 1) {\n    const synergyBonus = 1 + (quest.assignedAgents.length - 1) * 0.05;\n    xpReward *= Math.min(synergyBonus, 1.25);\n  }\n  \n  // Team performance bonus\n  if (completionData?.teamPerformanceBonus) {\n    xpReward *= completionData.teamPerformanceBonus;\n  }\n  \n  // Optimized streak bonus calculation\n  const streakBonus = calculateStreakBonusOptimized(agent);\n  xpReward *= streakBonus;\n  \n  const finalReward = Math.floor(xpReward);\n  setCache(cacheKey, finalReward);\n  return finalReward;\n}\n\n// Optimized streak calculation with caching\nexport function calculateStreakBonusOptimized(agent: Agent): number {\n  const cacheKey = `streak_${agent.id}_${agent.realtimeActivity.length}`;\n  const cached = getCache(cacheKey);\n  if (cached !== undefined) return cached;\n  \n  // Count recent XP-gaining activities more efficiently\n  let recentXpActivities = 0;\n  for (let i = 0; i < Math.min(agent.realtimeActivity.length, 10); i++) {\n    if (agent.realtimeActivity[i]?.xpGained && agent.realtimeActivity[i].xpGained! > 0) {\n      recentXpActivities++;\n    }\n  }\n  \n  let bonus = 1.0;\n  if (recentXpActivities >= 10) bonus = 1.3;\n  else if (recentXpActivities >= 5) bonus = 1.15;\n  else if (recentXpActivities >= 3) bonus = 1.05;\n  \n  setCache(cacheKey, bonus);\n  return bonus;\n}\n\n// Batch level calculation for multiple agents\nexport function batchCalculateLevels(agents: Agent[]): Array<{\n  agentId: number;\n  level: number;\n  currentLevelXp: number;\n  xpToNext: number;\n}> {\n  return agents.map(agent => ({\n    agentId: agent.id,\n    ...calculateLevelFromXp(agent.xp)\n  }));\n}\n\n// Optimized stat bonus application\nexport function applyLevelUpStatBonusOptimized(stats: AgentStats, newLevel: number): AgentStats {\n  const cacheKey = `statBonus_${newLevel}`;\n  const cached = getCache(cacheKey);\n  \n  let statBonus: number;\n  if (cached !== undefined) {\n    statBonus = cached;\n  } else {\n    statBonus = Math.floor(newLevel / 5) + 1;\n    setCache(cacheKey, statBonus);\n  }\n  \n  return {\n    intelligence: stats.intelligence + statBonus,\n    creativity: stats.creativity + statBonus,\n    reliability: stats.reliability + statBonus,\n    speed: stats.speed + statBonus,\n    leadership: stats.leadership + statBonus\n  };\n}\n\n// Batch XP application with minimal state changes\nexport function batchApplyXpToAgents(\n  agents: Agent[],\n  xpAwards: Array<{ agentId: number; amount: number; source: string }>\n): Agent[] {\n  const xpMap = new Map(xpAwards.map(award => [award.agentId, award]));\n  \n  return agents.map(agent => {\n    const award = xpMap.get(agent.id);\n    if (!award) return agent;\n    \n    const totalXp = agent.xp + award.amount;\n    const levelData = calculateLevelFromXp(totalXp);\n    const leveledUp = levelData.level > agent.level;\n    \n    return {\n      ...agent,\n      xp: levelData.currentLevelXp,\n      xpToNext: levelData.xpToNext,\n      level: levelData.level,\n      stats: leveledUp ? applyLevelUpStatBonusOptimized(agent.stats, levelData.level) : agent.stats,\n      realtimeActivity: [\n        {\n          timestamp: new Date().toISOString(),\n          action: award.source,\n          xpGained: award.amount\n        },\n        ...agent.realtimeActivity.slice(0, 49)\n      ]\n    };\n  });\n}\n\n// Performance monitoring for XP calculations\nexport function measureXpCalculationPerformance() {\n  return {\n    cacheSize: calculationCache.size,\n    cacheHitRate: getCacheHitRate(),\n    averageCalculationTime: getAverageCalculationTime(),\n    slowestCalculations: getSlowestCalculations()\n  };\n}\n\nlet cacheHits = 0;\nlet cacheMisses = 0;\nconst calculationTimes: number[] = [];\n\nfunction getCacheHitRate(): number {\n  const total = cacheHits + cacheMisses;\n  return total > 0 ? (cacheHits / total) * 100 : 0;\n}\n\nfunction getAverageCalculationTime(): number {\n  if (calculationTimes.length === 0) return 0;\n  return calculationTimes.reduce((sum, time) => sum + time, 0) / calculationTimes.length;\n}\n\nfunction getSlowestCalculations(): number[] {\n  return calculationTimes.sort((a, b) => b - a).slice(0, 5);\n}\n\n// Clear performance metrics\nexport function clearPerformanceMetrics() {\n  calculationCache.clear();\n  cacheHits = 0;\n  cacheMisses = 0;\n  calculationTimes.length = 0;\n}\n\n// Optimized utility functions\nexport const optimizedUtils = {\n  calculateXpToNextLevel,\n  calculateTotalXpForLevel,\n  calculateLevelFromXp,\n  calculateQuestXpRewardOptimized,\n  calculateStreakBonusOptimized,\n  batchCalculateLevels,\n  batchApplyXpToAgents,\n  measureXpCalculationPerformance,\n  clearPerformanceMetrics\n};\n\nexport default optimizedUtils;","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/reports/performance-report-generator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1076,1079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1076,1079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1114,1117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1114,1117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1155,1158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1155,1158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1288,1291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1288,1291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3442,3445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3442,3445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3463,3466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3463,3466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":104,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3485,3488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3485,3488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3939,3942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3939,3942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4780,4783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4780,4783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4800,4803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4800,4803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4955,4958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4955,4958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5468,5471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5468,5471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":172,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6025,6028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6025,6028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":196,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":196,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7046,7049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7046,7049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7740,7743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7740,7743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7760,7763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7760,7763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_benchmarkData' is defined but never used.","line":214,"column":79,"nodeType":null,"messageId":"unusedVar","endLine":214,"endColumn":93},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7783,7786],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7783,7786],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":218,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7953,7956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7953,7956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9573,9576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9573,9576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":20,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance report generator with comprehensive metrics and recommendations\nimport { performanceMonitor } from '../monitoring/performance-monitor';\nimport { webVitalsDashboard } from '../monitoring/web-vitals';\n// import { performanceBenchmark } from '../testing/performance-benchmarks';\n\nexport interface PerformanceIssue {\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  metric: string;\n  description: string;\n  impact: string;\n  recommendation: string;\n}\n\nexport interface PerformanceRecommendation {\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  category: string;\n  title: string;\n  description: string;\n  implementation: string;\n  estimatedImprovement: string;\n}\n\nexport interface DetailedPerformanceReport {\n  timestamp: string;\n  summary: {\n    overallScore: number;\n    grade: string;\n    criticalIssues: number;\n    recommendations: number;\n  };\n  webVitals: {\n    score: number;\n    metrics: Array<{\n      name: string;\n      value: number;\n      rating: string;\n      target: string;\n    }>;\n  };\n  performance: {\n    renderMetrics: Record<string, any>;\n    memoryUsage: Record<string, any>;\n    networkMetrics: Record<string, any>;\n  };\n  issues: PerformanceIssue[];\n  recommendations: PerformanceRecommendation[];\n  benchmarks: {\n    summary: Record<string, any>;\n    improvements: string[];\n  };\n}\n\nclass PerformanceReportGenerator {\n  async generateComprehensiveReport(): Promise<DetailedPerformanceReport> {\n    const timestamp = new Date().toISOString();\n    const performanceData = performanceMonitor.getPerformanceReport();\n    const webVitalsData = webVitalsDashboard.getLatestMetrics();\n    const benchmarkData = { summary: { averageImprovement: 0 }, details: {} }; // Mock benchmark data\n    \n    const overallScore = this.calculateOverallScore(performanceData, webVitalsData, benchmarkData);\n    const grade = this.calculateGrade(overallScore);\n    \n    const issues: PerformanceIssue[] = this.identifyCriticalIssues(performanceData, webVitalsData);\n    const recommendations: PerformanceRecommendation[] = this.generateRecommendations(performanceData, webVitalsData, benchmarkData);\n    \n    return {\n      timestamp,\n      summary: {\n        overallScore,\n        grade,\n        criticalIssues: issues.filter(i => i.severity === 'critical' || i.severity === 'high').length,\n        recommendations: recommendations.filter(r => r.priority === 'high' || r.priority === 'critical').length\n      },\n      webVitals: {\n        score: webVitalsDashboard.getPerformanceScore(),\n        metrics: webVitalsData.map(metric => ({\n          name: metric.name,\n          value: metric.value,\n          rating: metric.rating,\n          target: this.getMetricTarget(metric.name)\n        }))\n      },\n      performance: {\n        renderMetrics: performanceData.current || {},\n        memoryUsage: {\n          heapUsed: performanceData.current?.heapUsed || 0,\n          heapTotal: performanceData.current?.heapTotal || 0,\n          external: performanceData.current?.external || 0\n        },\n        networkMetrics: {\n          requestCount: performanceData.current?.requestCount || 0,\n          totalTransferSize: performanceData.current?.totalTransferSize || 0\n        }\n      },\n      issues,\n      recommendations,\n      benchmarks: {\n        summary: benchmarkData.summary || {},\n        improvements: this.identifyImprovements(benchmarkData)\n      }\n    };\n  }\n\n  private calculateOverallScore(performanceData: any, _webVitalsData: any[], benchmarkData: any): number {\n    const webVitalsScore = webVitalsDashboard.getPerformanceScore();\n    const performanceScore = this.calculatePerformanceScore(performanceData);\n    const benchmarkScore = benchmarkData.summary?.averageImprovement ? \n      Math.min(100, benchmarkData.summary.averageImprovement + 60) : 75;\n    \n    return Math.round((webVitalsScore * 0.4 + performanceScore * 0.4 + benchmarkScore * 0.2));\n  }\n\n  private calculatePerformanceScore(data: any): number {\n    if (!data?.current) return 75;\n    \n    let score = 100;\n    \n    // Deduct points for slow render times\n    if (data.current?.renderTime > 16) {\n      score -= Math.min(30, (data.current.renderTime - 16) * 2);\n    }\n    \n    // Deduct points for high memory usage\n    const memoryMB = (data.current?.heapUsed || 0) / 1024 / 1024;\n    if (memoryMB > 100) {\n      score -= Math.min(20, (memoryMB - 100) / 10);\n    }\n    \n    // Deduct points for warnings\n    score -= Math.min(25, (data?.warnings?.length || 0) * 5);\n    \n    return Math.max(0, Math.round(score));\n  }\n\n  private calculateGrade(score: number): string {\n    if (score >= 90) return 'A';\n    if (score >= 80) return 'B';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private identifyCriticalIssues(performanceData: any, webVitalsData: any[]): PerformanceIssue[] {\n    const issues: PerformanceIssue[] = [];\n    \n    // Check for critical web vitals issues\n    webVitalsData.forEach((vital: any) => {\n      if (vital?.rating === 'poor') {\n        issues.push({\n          severity: 'high',\n          metric: vital.name,\n          description: `${vital.name} is ${(vital.value || 0).toFixed(1)}ms (poor rating)`,\n          impact: 'Poor user experience and SEO ranking',\n          recommendation: `Optimize ${vital.name} to be under ${this.getMetricTarget(vital.name)}`\n        });\n      }\n    });\n    \n    // Check for performance budget violations\n    (performanceData?.warnings || []).forEach((warning: any) => {\n      issues.push({\n        severity: 'medium',\n        metric: warning?.metric || 'Unknown',\n        description: `${warning?.metric || 'Unknown'} exceeds budget: ${(warning?.current || 0).toFixed(1)} > ${warning?.budget || 0}`,\n        impact: 'Degraded performance and user experience',\n        recommendation: 'Optimize component rendering and reduce computational complexity'\n      });\n    });\n    \n    // Check component-specific issues\n    const componentReport = performanceData?.componentTimings || [];\n    componentReport.forEach((comp: any) => {\n      if ((comp?.averageRenderTime || 0) > 32) { // 2 frames\n        issues.push({\n          severity: 'high',\n          metric: comp?.component || 'Unknown Component',\n          description: `${comp?.component || 'Unknown Component'} renders slowly (${(comp?.averageRenderTime || 0).toFixed(1)}ms avg)`,\n          impact: 'Blocking UI updates and poor responsiveness',\n          recommendation: 'Use React.memo, useMemo, or useCallback to optimize component'\n        });\n      }\n      if ((comp?.renderCount || 0) > 50) {\n        issues.push({\n          severity: 'medium',\n          metric: comp?.component || 'Unknown Component',\n          description: `${comp?.component || 'Unknown Component'} re-renders frequently (${comp?.renderCount || 0} times)`,\n          impact: 'Unnecessary computations and battery drain',\n          recommendation: 'Check dependencies in useEffect and optimize state updates'\n        });\n      }\n    });\n    \n    return issues;\n  }\n\n  private identifyImprovements(benchmarkData: any): string[] {\n    const improvements: string[] = [];\n    \n    if ((benchmarkData?.summary?.averageImprovement || 0) > 30) {\n      improvements.push(`Optimizations achieved ${(benchmarkData?.summary?.averageImprovement || 0).toFixed(1)}% performance improvement`);\n    }\n    \n    if ((benchmarkData?.details?.agentRendering?.improvement || 0) > 25) {\n      improvements.push('Agent rendering optimizations show significant improvement');\n    }\n    \n    if ((benchmarkData?.details?.questProcessing?.improvement || 0) > 20) {\n      improvements.push('Quest processing performance has been enhanced');\n    }\n    \n    return improvements;\n  }\n\n  private generateRecommendations(performanceData: any, webVitalsData: any[], _benchmarkData: any): PerformanceRecommendation[] {\n    const recommendations: PerformanceRecommendation[] = [];\n    \n    // Web Vitals recommendations\n    webVitalsData.forEach((vital: any) => {\n      if (vital?.rating === 'needs-improvement' || vital?.rating === 'poor') {\n        recommendations.push(this.getWebVitalRecommendation(vital));\n      }\n    });\n    \n    // Component optimization recommendations\n    if ((performanceData?.warnings?.length || 0) > 3) {\n      recommendations.push({\n        priority: 'high',\n        category: 'Component Optimization',\n        title: 'Implement React Performance Patterns',\n        description: 'Multiple components are causing performance warnings',\n        implementation: 'Use React.memo, useMemo, useCallback, and lazy loading',\n        estimatedImprovement: '20-40% render time reduction'\n      });\n    }\n    \n    // Memory optimization recommendations\n    if ((performanceData?.current?.heapUsed || 0) > 100 * 1024 * 1024) {\n      recommendations.push({\n        priority: 'medium',\n        category: 'Memory Management',\n        title: 'Optimize Memory Usage',\n        description: 'High memory consumption detected',\n        implementation: 'Implement object pooling and cleanup event listeners',\n        estimatedImprovement: '15-30% memory reduction'\n      });\n    }\n    \n    // Bundle optimization recommendations\n    recommendations.push({\n      priority: 'medium',\n      category: 'Code Splitting',\n      title: 'Implement Advanced Code Splitting',\n      description: 'Reduce initial bundle size for faster loading',\n      implementation: 'Split components by route and feature, use dynamic imports',\n      estimatedImprovement: '25-50% faster initial load'\n    });\n    \n    return recommendations;\n  }\n\n  private getWebVitalRecommendation(vital: any): PerformanceRecommendation {\n    const recommendations = {\n      'FCP': {\n        priority: 'high' as const,\n        category: 'Loading Performance',\n        title: 'Optimize First Contentful Paint',\n        description: 'Reduce time to first contentful paint',\n        implementation: 'Optimize critical CSS, preload key resources, reduce server response time',\n        estimatedImprovement: '20-40% faster initial render'\n      },\n      'LCP': {\n        priority: 'high' as const,\n        category: 'Loading Performance', \n        title: 'Improve Largest Contentful Paint',\n        description: 'Optimize largest content element loading',\n        implementation: 'Optimize images, preload resources, reduce render-blocking resources',\n        estimatedImprovement: '30-60% faster content loading'\n      },\n      'CLS': {\n        priority: 'medium' as const,\n        category: 'Visual Stability',\n        title: 'Reduce Cumulative Layout Shift',\n        description: 'Minimize unexpected layout shifts',\n        implementation: 'Set dimensions for images/videos, reserve space for ads, avoid inserting content',\n        estimatedImprovement: '50-80% reduction in layout shifts'\n      },\n      'FID': {\n        priority: 'high' as const,\n        category: 'Interactivity',\n        title: 'Improve First Input Delay',\n        description: 'Reduce main thread blocking time',\n        implementation: 'Code splitting, reduce JavaScript execution time, use web workers',\n        estimatedImprovement: '40-70% faster interaction response'\n      }\n    };\n    \n    return recommendations[vital?.name as keyof typeof recommendations] || {\n      priority: 'medium',\n      category: 'Performance',\n      title: `Optimize ${vital?.name || 'Unknown'}`,\n      description: `Improve ${vital?.name || 'Unknown'} performance`,\n      implementation: 'Follow web performance best practices',\n      estimatedImprovement: '10-30% improvement'\n    };\n  }\n\n  private getMetricTarget(metricName: string): string {\n    const targets = {\n      'FCP': '1.8s',\n      'LCP': '2.5s',\n      'FID': '100ms',\n      'CLS': '0.1',\n      'TTFB': '800ms',\n      'TTI': '3.8s'\n    };\n    \n    return targets[metricName as keyof typeof targets] || 'Optimize';\n  }\n\n  async exportReport(format: 'json' | 'html' | 'csv' = 'json'): Promise<string> {\n    const report = await this.generateComprehensiveReport();\n    \n    switch (format) {\n      case 'json':\n        return JSON.stringify(report, null, 2);\n      case 'html':\n        return this.generateHTMLReport(report);\n      case 'csv':\n        return this.generateCSVReport(report);\n      default:\n        return JSON.stringify(report, null, 2);\n    }\n  }\n\n  private generateHTMLReport(report: DetailedPerformanceReport): string {\n    return `\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Performance Report - ${report.timestamp}</title>\n    <style>\n        body { font-family: system-ui, -apple-system, sans-serif; margin: 2rem; }\n        .score { font-size: 2rem; font-weight: bold; }\n        .good { color: #10b981; }\n        .warning { color: #f59e0b; }\n        .critical { color: #ef4444; }\n        .metric { display: flex; justify-content: space-between; padding: 0.5rem 0; }\n        .section { margin: 2rem 0; }\n        table { width: 100%; border-collapse: collapse; }\n        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #e5e7eb; }\n    </style>\n</head>\n<body>\n    <h1>Performance Report</h1>\n    <p>Generated: ${report.timestamp}</p>\n    \n    <div class=\"section\">\n        <h2>Summary</h2>\n        <div class=\"score ${report.summary.overallScore >= 80 ? 'good' : report.summary.overallScore >= 60 ? 'warning' : 'critical'}\">\n            Score: ${report.summary.overallScore} (${report.summary.grade})\n        </div>\n        <div>Critical Issues: ${report.summary.criticalIssues}</div>\n        <div>Recommendations: ${report.summary.recommendations}</div>\n    </div>\n    \n    <div class=\"section\">\n        <h2>Web Vitals</h2>\n        ${report.webVitals.metrics.map(metric => `\n            <div class=\"metric\">\n                <span>${metric.name}</span>\n                <span class=\"${metric.rating === 'good' ? 'good' : metric.rating === 'needs-improvement' ? 'warning' : 'critical'}\">\n                    ${metric.value.toFixed(1)}ms (${metric.rating})\n                </span>\n            </div>\n        `).join('')}\n    </div>\n    \n    <div class=\"section\">\n        <h2>Critical Issues</h2>\n        <table>\n            <thead>\n                <tr><th>Severity</th><th>Metric</th><th>Description</th><th>Recommendation</th></tr>\n            </thead>\n            <tbody>\n                ${report.issues.map(issue => `\n                    <tr>\n                        <td class=\"${issue.severity === 'critical' ? 'critical' : issue.severity === 'high' ? 'warning' : ''}\">${issue.severity}</td>\n                        <td>${issue.metric}</td>\n                        <td>${issue.description}</td>\n                        <td>${issue.recommendation}</td>\n                    </tr>\n                `).join('')}\n            </tbody>\n        </table>\n    </div>\n</body>\n</html>`;\n  }\n\n  private generateCSVReport(report: DetailedPerformanceReport): string {\n    const csvRows = [\n      ['Metric', 'Value', 'Status', 'Target'],\n      ...report.webVitals.metrics.map(metric => [\n        metric.name,\n        metric.value.toFixed(1),\n        metric.rating,\n        metric.target\n      ]),\n      [''],\n      ['Issue Type', 'Severity', 'Metric', 'Description'],\n      ...report.issues.map(issue => [\n        'Issue',\n        issue.severity,\n        issue.metric,\n        issue.description\n      ])\n    ];\n    \n    return csvRows.map(row => row.map(cell => `\"${cell}\"`).join(',')).join('\\n');\n  }\n}\n\nexport const performanceReportGenerator = new PerformanceReportGenerator();","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/testing/component-performance.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'result' is assigned a value but never used.","line":18,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'index' is defined but never used.","line":127,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":49}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Component performance tests\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport { performanceTestUtils, expectFastRender, expectLowMemoryUsage } from './setup-performance-tests';\nimport { OptimizedAgentCard, OptimizedXPBar, VirtualizedAgentList } from '../optimization/react-optimizations';\n\ndescribe('Component Performance Tests', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('OptimizedAgentCard', () => {\n    it('should render quickly with complex agent data', async () => {\n      const testAgent = performanceTestUtils.createTestAgent(1);\n      const mockRenderXPBar = vi.fn(() => <div>XP Bar</div>);\n      const mockOnSelect = vi.fn();\n\n      const { result, time } = await performanceTestUtils.measureTime(() => {\n        render(\n          <OptimizedAgentCard\n            agent={testAgent}\n            isLeveling={false}\n            onSelect={mockOnSelect}\n            renderXPBar={mockRenderXPBar}\n          />\n        );\n      });\n\n      expectFastRender(time);\n      expect(screen.getByText(testAgent.name)).toBeInTheDocument();\n    });\n\n    it('should handle rapid re-renders efficiently', async () => {\n      const testAgent = performanceTestUtils.createTestAgent(1);\n      const mockRenderXPBar = vi.fn(() => <div>XP Bar</div>);\n      const mockOnSelect = vi.fn();\n\n      const { time } = await performanceTestUtils.measureTime(() => {\n        // Simulate multiple rapid re-renders\n        for (let i = 0; i < 10; i++) {\n          const { rerender } = render(\n            <OptimizedAgentCard\n              agent={{ ...testAgent, xp: testAgent.xp + i }}\n              isLeveling={i % 2 === 0}\n              onSelect={mockOnSelect}\n              renderXPBar={mockRenderXPBar}\n            />\n          );\n          \n          rerender(\n            <OptimizedAgentCard\n              agent={{ ...testAgent, xp: testAgent.xp + i + 1 }}\n              isLeveling={i % 2 === 1}\n              onSelect={mockOnSelect}\n              renderXPBar={mockRenderXPBar}\n            />\n          );\n        }\n      });\n\n      // Should handle 20 renders in under 100ms\n      expect(time).toBeLessThan(100);\n    });\n  });\n\n  describe('OptimizedXPBar', () => {\n    it('should render XP bar with minimal computation', async () => {\n      const { time } = await performanceTestUtils.measureTime(() => {\n        render(\n          <OptimizedXPBar\n            current={750}\n            toNext={1000}\n            level={5}\n            isLeveling={false}\n          />\n        );\n      });\n\n      expectFastRender(time);\n    });\n\n    it('should handle level-up animations efficiently', async () => {\n      const { time } = await performanceTestUtils.measureTime(() => {\n        render(\n          <OptimizedXPBar\n            current={750}\n            toNext={1000}\n            level={5}\n            isLeveling={true}\n          />\n        );\n      });\n\n      expectFastRender(time);\n    });\n  });\n\n  describe('VirtualizedAgentList', () => {\n    it('should render large agent lists efficiently', async () => {\n      const largeAgentList = performanceTestUtils.generateTestData.agents(1000);\n      const mockRenderItem = vi.fn((agent, index) => (\n        <div key={agent.id} data-testid={`agent-${agent.id}`}>\n          {agent.name} - {index}\n        </div>\n      ));\n\n      const { time } = await performanceTestUtils.measureTime(() => {\n        render(\n          <VirtualizedAgentList\n            agents={largeAgentList}\n            renderItem={mockRenderItem}\n            itemHeight={200}\n            containerHeight={600}\n          />\n        );\n      });\n\n      // Should render 1000 agents (virtualized) in under 50ms\n      expect(time).toBeLessThan(50);\n      \n      // Should only render visible items (3-4 items for 600px container with 200px items)\n      expect(mockRenderItem).toHaveBeenCalledTimes(4); // 3 visible + 1 buffer\n    });\n\n    it('should handle scrolling efficiently', async () => {\n      const largeAgentList = performanceTestUtils.generateTestData.agents(1000);\n      const mockRenderItem = vi.fn((agent, index) => (\n        <div key={agent.id}>{agent.name}</div>\n      ));\n\n      const { container } = render(\n        <VirtualizedAgentList\n          agents={largeAgentList}\n          renderItem={mockRenderItem}\n          itemHeight={200}\n          containerHeight={600}\n        />\n      );\n\n      const scrollContainer = container.firstChild as HTMLElement;\n      \n      const { time } = await performanceTestUtils.measureTime(() => {\n        // Simulate rapid scrolling\n        for (let i = 0; i < 10; i++) {\n          scrollContainer.scrollTop = i * 200;\n          // Trigger scroll event\n          scrollContainer.dispatchEvent(new Event('scroll'));\n        }\n      });\n\n      // Scrolling should be very fast\n      expect(time).toBeLessThan(20);\n    });\n  });\n\n  describe('Memory Usage Tests', () => {\n    it('should not leak memory during component re-renders', () => {\n      const testAgent = performanceTestUtils.createTestAgent(1);\n      const mockRenderXPBar = vi.fn(() => <div>XP Bar</div>);\n      const mockOnSelect = vi.fn();\n\n      const memoryIncrease = performanceTestUtils.measureMemory(() => {\n        // Render and unmount component 100 times\n        for (let i = 0; i < 100; i++) {\n          const { unmount } = render(\n            <OptimizedAgentCard\n              agent={testAgent}\n              isLeveling={false}\n              onSelect={mockOnSelect}\n              renderXPBar={mockRenderXPBar}\n            />\n          );\n          unmount();\n        }\n      });\n\n      expectLowMemoryUsage(memoryIncrease);\n    });\n  });\n\n  describe('Real-world Performance Scenarios', () => {\n    it('should handle complete app re-render efficiently', async () => {\n      const largeAgentList = performanceTestUtils.generateTestData.agents(50);\n      \n      const { time } = await performanceTestUtils.measureTime(() => {\n        // Simulate full app re-render with state changes\n        largeAgentList.forEach((agent, index) => {\n          render(\n            <OptimizedAgentCard\n              agent={{ ...agent, xp: agent.xp + index }}\n              isLeveling={index % 5 === 0}\n              onSelect={vi.fn()}\n              renderXPBar={vi.fn(() => <div>XP</div>)}\n            />\n          );\n        });\n      });\n\n      // 50 agent cards should render in under 200ms\n      expect(time).toBeLessThan(200);\n    });\n\n    it('should handle concurrent animations efficiently', async () => {\n      const testAgents = performanceTestUtils.generateTestData.agents(10);\n      \n      const { time } = await performanceTestUtils.measureTime(() => {\n        // Render multiple leveling agents simultaneously\n        testAgents.forEach(agent => {\n          render(\n            <OptimizedXPBar\n              current={agent.xp}\n              toNext={agent.xpToNext}\n              level={agent.level}\n              isLeveling={true}\n            />\n          );\n        });\n      });\n\n      // Multiple concurrent animations should start quickly\n      expect(time).toBeLessThan(50);\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/testing/performance-benchmarks.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":172,"column":9,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":172,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8509,8512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8509,8512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance benchmarking suite for Agent Company RPG\nimport { Agent } from '../../src/types/agent';\nimport { Quest } from '../../src/types/quest';\nimport { initialAgents } from '../../src/data/agents';\nimport { optimizedUtils } from '../optimization/xp-calculator-optimized';\nimport * as originalUtils from '../../src/utils/xpCalculator';\n\nexport interface BenchmarkResult {\n  testName: string;\n  originalTime: number;\n  optimizedTime: number;\n  improvement: number; // Percentage improvement\n  iterations: number;\n  memoryUsage?: {\n    before: number;\n    after: number;\n  };\n}\n\nexport class PerformanceBenchmark {\n  private results: BenchmarkResult[] = [];\n\n  // Benchmark XP calculation performance\n  async benchmarkXpCalculations(iterations = 1000): Promise<BenchmarkResult> {\n    const testAgents = this.generateTestAgents(100);\n    const testQuest = this.generateTestQuest();\n    \n    const memoryBefore = this.getMemoryUsage();\n    \n    // Test original implementation\n    const originalStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      testAgents.forEach(agent => {\n        originalUtils.calculateQuestXpReward(testQuest, agent, 30, 2);\n      });\n    }\n    const originalTime = performance.now() - originalStart;\n    \n    // Test optimized implementation\n    const optimizedStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      testAgents.forEach(agent => {\n        optimizedUtils.calculateQuestXpRewardOptimized(testQuest, agent, {\n          completionTime: 30,\n          optionalObjectivesCompleted: 2\n        });\n      });\n    }\n    const optimizedTime = performance.now() - optimizedStart;\n    \n    const memoryAfter = this.getMemoryUsage();\n    const improvement = ((originalTime - optimizedTime) / originalTime) * 100;\n    \n    const result: BenchmarkResult = {\n      testName: 'XP Calculations',\n      originalTime,\n      optimizedTime,\n      improvement,\n      iterations: iterations * testAgents.length,\n      memoryUsage: {\n        before: memoryBefore,\n        after: memoryAfter\n      }\n    };\n    \n    this.results.push(result);\n    return result;\n  }\n\n  // Benchmark level calculation performance\n  async benchmarkLevelCalculations(iterations = 10000): Promise<BenchmarkResult> {\n    const testXpValues = this.generateTestXpValues(1000);\n    \n    const memoryBefore = this.getMemoryUsage();\n    \n    // Test original implementation\n    const originalStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      testXpValues.forEach(xp => {\n        originalUtils.calculateLevelFromXp(xp);\n      });\n    }\n    const originalTime = performance.now() - originalStart;\n    \n    // Test optimized implementation\n    const optimizedStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      testXpValues.forEach(xp => {\n        optimizedUtils.calculateLevelFromXp(xp);\n      });\n    }\n    const optimizedTime = performance.now() - optimizedStart;\n    \n    const memoryAfter = this.getMemoryUsage();\n    const improvement = ((originalTime - optimizedTime) / originalTime) * 100;\n    \n    const result: BenchmarkResult = {\n      testName: 'Level Calculations',\n      originalTime,\n      optimizedTime,\n      improvement,\n      iterations: iterations * testXpValues.length,\n      memoryUsage: {\n        before: memoryBefore,\n        after: memoryAfter\n      }\n    };\n    \n    this.results.push(result);\n    return result;\n  }\n\n  // Benchmark batch operations\n  async benchmarkBatchOperations(iterations = 100): Promise<BenchmarkResult> {\n    const testAgents = this.generateTestAgents(50);\n    const testXpAwards = testAgents.map((agent, index) => ({\n      agentId: agent.id,\n      amount: 100 + (index * 10),\n      source: `Benchmark test ${index}`\n    }));\n    \n    const memoryBefore = this.getMemoryUsage();\n    \n    // Test individual operations\n    const originalStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      testXpAwards.forEach(award => {\n        const agent = testAgents.find(a => a.id === award.agentId)!;\n        originalUtils.applyXpToAgent(agent, award.amount, award.source);\n      });\n    }\n    const originalTime = performance.now() - originalStart;\n    \n    // Test batch operations\n    const optimizedStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      optimizedUtils.batchApplyXpToAgents(testAgents, testXpAwards);\n    }\n    const optimizedTime = performance.now() - optimizedStart;\n    \n    const memoryAfter = this.getMemoryUsage();\n    const improvement = ((originalTime - optimizedTime) / originalTime) * 100;\n    \n    const result: BenchmarkResult = {\n      testName: 'Batch XP Operations',\n      originalTime,\n      optimizedTime,\n      improvement,\n      iterations: iterations * testXpAwards.length,\n      memoryUsage: {\n        before: memoryBefore,\n        after: memoryAfter\n      }\n    };\n    \n    this.results.push(result);\n    return result;\n  }\n\n  // Benchmark React component render performance\n  async benchmarkComponentRenders(): Promise<BenchmarkResult> {\n    const testAgents = this.generateTestAgents(20);\n    const iterations = 100;\n    \n    const memoryBefore = this.getMemoryUsage();\n    \n    // Simulate component renders with complex calculations\n    const originalStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      testAgents.forEach(agent => {\n        // Simulate expensive calculations that happen during render\n        (agent.xp / agent.xpToNext) * 100;\n        testAgents.reduce((sum, a) => sum + a.level, 0);\n        testAgents.reduce((sum, a) => sum + a.knowledgeBase.totalMemories, 0);\n      });\n    }\n    const originalTime = performance.now() - originalStart;\n    \n    // Simulate optimized renders with memoization\n    const memoizedCalculations = new Map();\n    const optimizedStart = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      testAgents.forEach(agent => {\n        const key = `${agent.id}_${agent.xp}_${agent.xpToNext}`;\n        if (!memoizedCalculations.has(key)) {\n          const percentage = (agent.xp / agent.xpToNext) * 100;\n          memoizedCalculations.set(key, percentage);\n        }\n      });\n      \n      // Cache aggregate calculations\n      if (!memoizedCalculations.has('totalLevels')) {\n        const totalLevels = testAgents.reduce((sum, a) => sum + a.level, 0);\n        memoizedCalculations.set('totalLevels', totalLevels);\n      }\n      if (!memoizedCalculations.has('totalMemories')) {\n        const totalMemories = testAgents.reduce((sum, a) => sum + a.knowledgeBase.totalMemories, 0);\n        memoizedCalculations.set('totalMemories', totalMemories);\n      }\n    }\n    const optimizedTime = performance.now() - optimizedStart;\n    \n    const memoryAfter = this.getMemoryUsage();\n    const improvement = ((originalTime - optimizedTime) / originalTime) * 100;\n    \n    const result: BenchmarkResult = {\n      testName: 'Component Renders',\n      originalTime,\n      optimizedTime,\n      improvement,\n      iterations: iterations * testAgents.length,\n      memoryUsage: {\n        before: memoryBefore,\n        after: memoryAfter\n      }\n    };\n    \n    this.results.push(result);\n    return result;\n  }\n\n  // Run all benchmarks\n  async runFullBenchmarkSuite(): Promise<BenchmarkResult[]> {\n    console.log('Starting performance benchmark suite...');\n    \n    const results = await Promise.all([\n      this.benchmarkXpCalculations(),\n      this.benchmarkLevelCalculations(),\n      this.benchmarkBatchOperations(),\n      this.benchmarkComponentRenders()\n    ]);\n    \n    console.log('Benchmark suite completed!');\n    return results;\n  }\n\n  // Generate comprehensive performance report\n  generatePerformanceReport(): {\n    summary: {\n      averageImprovement: number;\n      totalTestsRun: number;\n      memoryEfficiency: number;\n    };\n    results: BenchmarkResult[];\n    recommendations: string[];\n  } {\n    const averageImprovement = this.results.reduce((sum, r) => sum + r.improvement, 0) / this.results.length;\n    const totalTests = this.results.reduce((sum, r) => sum + r.iterations, 0);\n    \n    const memoryEfficiency = this.calculateMemoryEfficiency();\n    const recommendations = this.generateOptimizationRecommendations();\n    \n    return {\n      summary: {\n        averageImprovement,\n        totalTestsRun: totalTests,\n        memoryEfficiency\n      },\n      results: [...this.results],\n      recommendations\n    };\n  }\n\n  private getMemoryUsage(): number {\n    if ('memory' in performance) {\n      return (performance as any).memory.usedJSHeapSize;\n    }\n    return 0;\n  }\n\n  private calculateMemoryEfficiency(): number {\n    const memoryResults = this.results.filter(r => r.memoryUsage);\n    if (memoryResults.length === 0) return 100;\n    \n    const avgMemoryIncrease = memoryResults.reduce((sum, r) => {\n      const increase = r.memoryUsage!.after - r.memoryUsage!.before;\n      return sum + increase;\n    }, 0) / memoryResults.length;\n    \n    // Return efficiency as percentage (lower memory increase = higher efficiency)\n    return Math.max(0, 100 - (avgMemoryIncrease / 1024 / 1024)); // Convert to MB\n  }\n\n  private generateOptimizationRecommendations(): string[] {\n    const recommendations = [];\n    \n    const avgImprovement = this.results.reduce((sum, r) => sum + r.improvement, 0) / this.results.length;\n    \n    if (avgImprovement < 20) {\n      recommendations.push('Consider implementing Web Workers for heavy calculations');\n      recommendations.push('Add more aggressive memoization for frequently accessed data');\n    }\n    \n    if (avgImprovement > 50) {\n      recommendations.push('Excellent optimization results! Consider applying similar patterns to other components');\n    }\n    \n    const memoryEfficiency = this.calculateMemoryEfficiency();\n    if (memoryEfficiency < 80) {\n      recommendations.push('Implement object pooling for frequently created objects');\n      recommendations.push('Add garbage collection optimization with WeakMap/WeakSet');\n    }\n    \n    recommendations.push('Monitor performance in production with real user data');\n    recommendations.push('Set up automated performance regression testing');\n    \n    return recommendations;\n  }\n\n  private generateTestAgents(count: number): Agent[] {\n    const agents: Agent[] = [];\n    for (let i = 0; i < count; i++) {\n      agents.push({\n        ...initialAgents[i % initialAgents.length],\n        id: i + 1000, // Unique IDs\n        xp: Math.floor(Math.random() * 5000),\n        level: Math.floor(Math.random() * 20) + 1\n      });\n    }\n    return agents;\n  }\n\n  private generateTestQuest(): Quest {\n    return {\n      id: 'benchmark-quest',\n      title: 'Benchmark Quest',\n      description: 'A test quest for benchmarking',\n      type: 'side',\n      category: 'Investigation',\n      difficulty: 'Medium',\n      status: 'active',\n      icon: '‚öîÔ∏è',\n      objectives: [\n        { id: '1', description: 'Test objective', completed: true, progress: 1, maxProgress: 1 },\n        { id: '2', description: 'Optional objective', completed: true, progress: 1, maxProgress: 1, optional: true }\n      ],\n      currentObjectiveIndex: 0,\n      progressPercentage: 100,\n      requirements: {},\n      rewards: { xp: 150 },\n      bonusRewards: { xp: 50 },\n      assignedAgents: [1000, 1001],\n      recommendedTeamSize: 2,\n      autoAssign: false,\n      dialogue: [],\n      createdAt: new Date(),\n      repeatable: false,\n      timeLimit: 60\n    };\n  }\n\n  private generateTestXpValues(count: number): number[] {\n    const values = [];\n    for (let i = 0; i < count; i++) {\n      values.push(Math.floor(Math.random() * 50000)); // Random XP up to level ~25\n    }\n    return values;\n  }\n\n  clearResults() {\n    this.results = [];\n  }\n\n  getResults() {\n    return [...this.results];\n  }\n}\n\n// Global benchmark instance\nexport const performanceBenchmark = new PerformanceBenchmark();\n\n// Utility functions for quick performance tests\nexport function quickBenchmark(testFunction: () => void, iterations = 1000): number {\n  const start = performance.now();\n  for (let i = 0; i < iterations; i++) {\n    testFunction();\n  }\n  return performance.now() - start;\n}\n\nexport function comparePerformance(\n  originalFn: () => void,\n  optimizedFn: () => void,\n  iterations = 1000\n): { improvement: number; originalTime: number; optimizedTime: number } {\n  const originalTime = quickBenchmark(originalFn, iterations);\n  const optimizedTime = quickBenchmark(optimizedFn, iterations);\n  const improvement = ((originalTime - optimizedTime) / originalTime) * 100;\n  \n  return { improvement, originalTime, optimizedTime };\n}\n\nexport default performanceBenchmark;","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/testing/setup-performance-tests.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2324,2327],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2324,2327],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2331,2334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2331,2334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance testing setup and utilities\nimport '@testing-library/jest-dom';\n\n// Mock performance APIs for testing environment\n(global as unknown).performance = {\n  now: () => Date.now(),\n  mark: () => {},\n  measure: () => {},\n  getEntriesByType: () => [],\n  getEntriesByName: () => [],\n  clearMarks: () => {},\n  clearMeasures: () => {},\n  memory: {\n    usedJSHeapSize: 10 * 1024 * 1024, // 10MB\n    totalJSHeapSize: 20 * 1024 * 1024, // 20MB\n    jsHeapSizeLimit: 100 * 1024 * 1024 // 100MB\n  }\n};\n\n// Mock PerformanceObserver for testing\n(global as unknown).PerformanceObserver = class MockPerformanceObserver {\n  constructor(private callback: (list: unknown) => void) {}\n  observe() {}\n  disconnect() {}\n};\n\n// Mock requestAnimationFrame\n(global as unknown).requestAnimationFrame = (callback: FrameRequestCallback) => {\n  return setTimeout(callback, 16); // ~60fps\n};\n\n(global as unknown).cancelAnimationFrame = (id: number) => {\n  clearTimeout(id);\n};\n\n// Performance test utilities\nexport const performanceTestUtils = {\n  // Create deterministic test data\n  createTestAgent: (id: number) => ({\n    id,\n    name: `Test Agent ${id}`,\n    class: 'Code Master',\n    level: Math.floor(Math.random() * 20) + 1,\n    xp: Math.floor(Math.random() * 5000),\n    xpToNext: 1000,\n    stats: {\n      intelligence: 75,\n      creativity: 65,\n      reliability: 80,\n      speed: 70,\n      leadership: 60\n    },\n    specializations: ['Testing', 'Performance'],\n    currentMission: 'Running tests',\n    personality: 'Methodical',\n    avatar: 'üß™',\n    knowledgeBase: {\n      totalMemories: 100,\n      recentLearning: 'Performance testing',\n      knowledgeDomains: {\n        testing: 90,\n        performance: 85\n      },\n      crawlingProgress: {\n        active: false,\n        lastUrl: '',\n        pagesLearned: 0,\n        knowledgeGained: 0\n      }\n    },\n    equipment: {\n      primary: 'Test Framework',\n      secondary: 'Performance Monitor',\n      utility: 'Benchmark Suite'\n    },\n    relationships: [],\n    skillTree: {\n      'Testing Mastery': { level: 5, maxLevel: 10, unlocked: true }\n    },\n    realtimeActivity: [\n      {\n        timestamp: new Date().toISOString(),\n        action: 'Performance testing',\n        xpGained: 10\n      }\n    ]\n  }),\n\n  // Measure function execution time\n  measureTime: async (fn: () => Promise<any> | any): Promise<{ result: unknown; time: number }> => {\n    const start = performance.now();\n    const result = await fn();\n    const time = performance.now() - start;\n    return { result, time };\n  },\n\n  // Create performance baseline\n  createBaseline: (testName: string, iterations: number, fn: () => void) => {\n    const times: number[] = [];\n    \n    for (let i = 0; i < iterations; i++) {\n      const start = performance.now();\n      fn();\n      times.push(performance.now() - start);\n    }\n    \n    return {\n      testName,\n      iterations,\n      averageTime: times.reduce((sum, time) => sum + time, 0) / times.length,\n      minTime: Math.min(...times),\n      maxTime: Math.max(...times),\n      medianTime: times.sort((a, b) => a - b)[Math.floor(times.length / 2)]\n    };\n  },\n\n  // Memory usage measurement\n  measureMemory: (fn: () => void) => {\n    const before = (performance as unknown).memory.usedJSHeapSize;\n    fn();\n    const after = (performance as unknown).memory.usedJSHeapSize;\n    return after - before;\n  },\n\n  // Assert performance requirements\n  expectPerformance: (actualTime: number, maxTime: number, testName: string) => {\n    if (actualTime > maxTime) {\n      throw new Error(\n        `Performance assertion failed for ${testName}: ` +\n        `${actualTime.toFixed(2)}ms > ${maxTime}ms (${((actualTime / maxTime - 1) * 100).toFixed(1)}% slower)`\n      );\n    }\n  },\n\n  // Generate large test datasets\n  generateTestData: {\n    agents: (count: number) => Array.from({ length: count }, (_, i) => \n      performanceTestUtils.createTestAgent(i + 1)\n    ),\n    \n    quests: (count: number) => Array.from({ length: count }, (_, i) => ({\n      id: `quest-${i}`,\n      title: `Test Quest ${i}`,\n      description: `Performance test quest number ${i}`,\n      type: 'side',\n      category: 'Investigation',\n      difficulty: 'Medium',\n      status: 'available',\n      icon: '‚öîÔ∏è',\n      objectives: [\n        { id: '1', description: 'Test objective', completed: false, progress: 0, maxProgress: 1 }\n      ],\n      currentObjectiveIndex: 0,\n      progressPercentage: 0,\n      requirements: {},\n      rewards: { xp: 100 + i * 10 },\n      assignedAgents: [],\n      recommendedTeamSize: 2,\n      autoAssign: false,\n      dialogue: [],\n      createdAt: new Date(),\n      repeatable: false\n    }))\n  }\n};\n\n// Performance assertion helpers\nexport function expectFastRender(renderTime: number) {\n  performanceTestUtils.expectPerformance(renderTime, 16, 'Component render');\n}\n\nexport function expectFastCalculation(calcTime: number) {\n  performanceTestUtils.expectPerformance(calcTime, 1, 'XP calculation');\n}\n\nexport function expectLowMemoryUsage(memoryIncrease: number) {\n  const maxMemoryIncrease = 5 * 1024 * 1024; // 5MB\n  if (memoryIncrease > maxMemoryIncrease) {\n    throw new Error(\n      `Memory usage too high: ${(memoryIncrease / 1024 / 1024).toFixed(1)}MB > 5MB`\n    );\n  }\n}\n\nexport default performanceTestUtils;","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/testing/vitest-performance.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/performance/testing/xp-calculator.bench.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/App-optimized.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/components/AgentSheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/components/LevelUpNotification.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/components/OptimizedAgentCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/components/QuestBoard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/components/__tests__/XPBar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/data/agents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/data/quests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/hooks/useLevelProgression.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/hooks/useOptimizedAgents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/hooks/useVirtualized.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/main-optimized.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/test/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/types/agent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/types/quest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/utils/levelProgression.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/src/utils/xpCalculator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/components/AgentSheet.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/components/LevelUpNotification.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userEvent' is defined but never used.","line":3,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LevelUpNotification from '../../src/components/LevelUpNotification';\nimport { LevelUpEvent } from '../../src/utils/levelProgression';\n\n// Mock requestAnimationFrame for animation testing\nglobal.requestAnimationFrame = vi.fn((cb) => {\n  setTimeout(cb, 16);\n  return 1;\n});\n\nglobal.cancelAnimationFrame = vi.fn();\n\ndescribe('LevelUpNotification Component', () => {\n  let mockLevelUpEvent: LevelUpEvent;\n  let mockOnDismiss: ReturnType<typeof vi.fn>;\n\n  beforeEach(() => {\n    mockLevelUpEvent = {\n      agentId: 1,\n      oldLevel: 5,\n      newLevel: 6,\n      xpGained: 250,\n      source: 'Quest Completion',\n      unlockedSkills: ['Advanced Debugging', 'Code Optimization'],\n      statIncreases: [\n        { stat: 'intelligence', amount: 2, reason: 'Level Up Bonus' },\n        { stat: 'reliability', amount: 1, reason: 'Experience Gain' }\n      ],\n      timestamp: new Date()\n    };\n\n    mockOnDismiss = vi.fn();\n  });\n\n  afterEach(() => {\n    vi.clearAllTimers();\n  });\n\n  describe('Rendering', () => {\n    it('should render level up notification with basic information', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      expect(screen.getByText('Level Up!')).toBeInTheDocument();\n      expect(screen.getByText('Level 6')).toBeInTheDocument();\n      expect(screen.getByText('+250 XP')).toBeInTheDocument();\n      expect(screen.getByText('Quest Completion')).toBeInTheDocument();\n    });\n\n    it('should render unlocked skills', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      expect(screen.getByText('New Skills Unlocked!')).toBeInTheDocument();\n      expect(screen.getByText('Advanced Debugging')).toBeInTheDocument();\n      expect(screen.getByText('Code Optimization')).toBeInTheDocument();\n    });\n\n    it('should render stat increases', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      expect(screen.getByText('Stat Increases')).toBeInTheDocument();\n      expect(screen.getByText('Intelligence +2')).toBeInTheDocument();\n      expect(screen.getByText('Reliability +1')).toBeInTheDocument();\n    });\n\n    it('should not render when not visible', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={false}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      expect(screen.queryByText('Level Up!')).not.toBeInTheDocument();\n    });\n\n    it('should render without unlocked skills', () => {\n      const eventWithoutSkills = {\n        ...mockLevelUpEvent,\n        unlockedSkills: []\n      };\n\n      render(\n        <LevelUpNotification \n          levelUpEvent={eventWithoutSkills}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      expect(screen.getByText('Level Up!')).toBeInTheDocument();\n      expect(screen.queryByText('New Skills Unlocked!')).not.toBeInTheDocument();\n    });\n\n    it('should render without stat increases', () => {\n      const eventWithoutStats = {\n        ...mockLevelUpEvent,\n        statIncreases: []\n      };\n\n      render(\n        <LevelUpNotification \n          levelUpEvent={eventWithoutStats}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      expect(screen.getByText('Level Up!')).toBeInTheDocument();\n      expect(screen.queryByText('Stat Increases')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('Animation and Visual Effects', () => {\n    it('should apply entrance animation when becoming visible', async () => {\n      const { rerender } = render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={false}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      rerender(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const notification = screen.getByRole('dialog');\n      expect(notification).toHaveClass('animate-scale-in');\n    });\n\n    it('should apply glow effect to level display', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const levelDisplay = screen.getByText('Level 6');\n      expect(levelDisplay).toHaveClass('text-yellow-400', 'animate-pulse');\n    });\n\n    it('should show celebration particles', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const particles = screen.getByTestId('celebration-particles');\n      expect(particles).toBeInTheDocument();\n    });\n\n    it('should animate skill reveals sequentially', async () => {\n      vi.useFakeTimers();\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      // Initially, skills should be hidden or have delayed animation\n      const skills = screen.getAllByText(/Advanced Debugging|Code Optimization/);\n      expect(skills[0]).toHaveClass('animate-fade-in-delay-1');\n      expect(skills[1]).toHaveClass('animate-fade-in-delay-2');\n\n      vi.useRealTimers();\n    });\n\n    it('should animate stat increases with counter effect', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const statIncrease = screen.getByText('Intelligence +2');\n      expect(statIncrease).toHaveClass('animate-count-up');\n    });\n  });\n\n  describe('User Interaction', () => {\n    it('should call onDismiss when close button is clicked', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const closeButton = screen.getByRole('button', { name: /close/i });\n      await user.click(closeButton);\n\n      expect(mockOnDismiss).toHaveBeenCalled();\n    });\n\n    it('should call onDismiss when clicking outside notification', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <div data-testid=\"backdrop\">\n          <LevelUpNotification \n            levelUpEvent={mockLevelUpEvent}\n            isVisible={true}\n            onDismiss={mockOnDismiss}\n          />\n        </div>\n      );\n\n      const backdrop = screen.getByTestId('backdrop');\n      await user.click(backdrop);\n\n      expect(mockOnDismiss).toHaveBeenCalled();\n    });\n\n    it('should not dismiss when clicking on the notification content', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const notification = screen.getByRole('dialog');\n      await user.click(notification);\n\n      expect(mockOnDismiss).not.toHaveBeenCalled();\n    });\n\n    it('should support keyboard dismissal with Escape key', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      await user.keyboard('{Escape}');\n\n      expect(mockOnDismiss).toHaveBeenCalled();\n    });\n  });\n\n  describe('Auto-dismiss Functionality', () => {\n    it('should auto-dismiss after specified duration', async () => {\n      vi.useFakeTimers();\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n          autoDismissDelay={3000}\n        />\n      );\n\n      expect(mockOnDismiss).not.toHaveBeenCalled();\n\n      vi.advanceTimersByTime(3000);\n\n      expect(mockOnDismiss).toHaveBeenCalled();\n      \n      vi.useRealTimers();\n    });\n\n    it('should not auto-dismiss when delay is not provided', async () => {\n      vi.useFakeTimers();\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      vi.advanceTimersByTime(5000);\n\n      expect(mockOnDismiss).not.toHaveBeenCalled();\n      \n      vi.useRealTimers();\n    });\n\n    it('should cancel auto-dismiss when manually dismissed', async () => {\n      vi.useFakeTimers();\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n          autoDismissDelay={3000}\n        />\n      );\n\n      // Manually dismiss before auto-dismiss\n      const closeButton = screen.getByRole('button', { name: /close/i });\n      await user.click(closeButton);\n\n      expect(mockOnDismiss).toHaveBeenCalledTimes(1);\n\n      // Advance time to when auto-dismiss would occur\n      vi.advanceTimersByTime(3000);\n\n      // Should not be called again\n      expect(mockOnDismiss).toHaveBeenCalledTimes(1);\n      \n      vi.useRealTimers();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper ARIA attributes', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const notification = screen.getByRole('dialog');\n      expect(notification).toHaveAttribute('aria-labelledby');\n      expect(notification).toHaveAttribute('aria-describedby');\n      expect(notification).toHaveAttribute('role', 'dialog');\n    });\n\n    it('should trap focus within notification', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const closeButton = screen.getByRole('button', { name: /close/i });\n      \n      // Focus should be on close button initially\n      closeButton.focus();\n      expect(closeButton).toHaveFocus();\n\n      // Tabbing should cycle within the notification\n      await user.tab();\n      // Focus should stay within notification bounds\n    });\n\n    it('should announce level up to screen readers', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const announcement = screen.getByRole('status');\n      expect(announcement).toHaveAttribute('aria-live', 'polite');\n      expect(announcement).toHaveTextContent(/level up.*level 6/i);\n    });\n\n    it('should have high contrast colors for visibility', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const notification = screen.getByRole('dialog');\n      expect(notification).toHaveClass('bg-gray-900', 'text-white');\n    });\n  });\n\n  describe('Multiple Level Ups', () => {\n    it('should handle multiple level increases', () => {\n      const multipleLevelEvent = {\n        ...mockLevelUpEvent,\n        oldLevel: 5,\n        newLevel: 8,\n        xpGained: 1500\n      };\n\n      render(\n        <LevelUpNotification \n          levelUpEvent={multipleLevelEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      expect(screen.getByText('Level 8')).toBeInTheDocument();\n      expect(screen.getByText('+3 Levels!')).toBeInTheDocument();\n      expect(screen.getByText('+1500 XP')).toBeInTheDocument();\n    });\n\n    it('should show enhanced animation for multiple levels', () => {\n      const multipleLevelEvent = {\n        ...mockLevelUpEvent,\n        oldLevel: 5,\n        newLevel: 8\n      };\n\n      render(\n        <LevelUpNotification \n          levelUpEvent={multipleLevelEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      const notification = screen.getByRole('dialog');\n      expect(notification).toHaveClass('animate-mega-level-up');\n    });\n  });\n\n  describe('Performance', () => {\n    it('should cleanup animation timers on unmount', () => {\n      const { unmount } = render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n          autoDismissDelay={3000}\n        />\n      );\n\n      // Start some animations\n      expect(() => unmount()).not.toThrow();\n    });\n\n    it('should handle rapid visibility changes gracefully', () => {\n      const { rerender } = render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n        />\n      );\n\n      // Rapidly toggle visibility\n      for (let i = 0; i < 10; i++) {\n        rerender(\n          <LevelUpNotification \n            levelUpEvent={mockLevelUpEvent}\n            isVisible={i % 2 === 0}\n            onDismiss={mockOnDismiss}\n          />\n        );\n      }\n\n      expect(() => {}).not.toThrow();\n    });\n  });\n\n  describe('Sound Integration', () => {\n    beforeEach(() => {\n      // Mock Audio API\n      global.Audio = vi.fn().mockImplementation(() => ({\n        play: vi.fn().mockResolvedValue(undefined),\n        pause: vi.fn(),\n        addEventListener: vi.fn(),\n        removeEventListener: vi.fn()\n      }));\n    });\n\n    it('should play level up sound when shown', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n          playSound={true}\n        />\n      );\n\n      expect(global.Audio).toHaveBeenCalledWith('/sounds/level-up.wav');\n    });\n\n    it('should not play sound when disabled', () => {\n      render(\n        <LevelUpNotification \n          levelUpEvent={mockLevelUpEvent}\n          isVisible={true}\n          onDismiss={mockOnDismiss}\n          playSound={false}\n        />\n      );\n\n      expect(global.Audio).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle missing level up event gracefully', () => {\n      expect(() => {\n        render(\n          <LevelUpNotification \n            levelUpEvent={null as unknown}\n            isVisible={true}\n            onDismiss={mockOnDismiss}\n          />\n        );\n      }).not.toThrow();\n    });\n\n    it('should handle malformed stat increases', () => {\n      const malformedEvent = {\n        ...mockLevelUpEvent,\n        statIncreases: [\n          { stat: null, amount: 2, reason: 'Test' },\n          { stat: 'intelligence', amount: null, reason: 'Test' }\n        ]\n      } as unknown;\n\n      expect(() => {\n        render(\n          <LevelUpNotification \n            levelUpEvent={malformedEvent}\n            isVisible={true}\n            onDismiss={mockOnDismiss}\n          />\n        );\n      }).not.toThrow();\n    });\n\n    it('should handle malformed unlocked skills', () => {\n      const malformedEvent = {\n        ...mockLevelUpEvent,\n        unlockedSkills: [null, undefined, 'Valid Skill']\n      } as unknown;\n\n      expect(() => {\n        render(\n          <LevelUpNotification \n            levelUpEvent={malformedEvent}\n            isVisible={true}\n            onDismiss={mockOnDismiss}\n          />\n        );\n      }).not.toThrow();\n\n      expect(screen.getByText('Valid Skill')).toBeInTheDocument();\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/components/QuestBoard.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userEvent' is defined but never used.","line":3,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport QuestBoard from '../../src/components/QuestBoard';\nimport { Quest } from '../../src/types/quest';\nimport { Agent } from '../../src/types/agent';\n\n// Mock the level progression hook\nvi.mock('../../src/hooks/useLevelProgression', () => ({\n  useLevelProgression: () => ({\n    completeQuest: vi.fn(),\n    calculatePreviewXp: vi.fn(() => ({\n      newLevel: 5,\n      levelUp: false,\n      xpProgress: 450,\n      xpToNext: 550\n    })),\n    isProcessing: false\n  })\n}));\n\ndescribe('QuestBoard Component', () => {\n  let mockQuests: Quest[];\n  let mockAgents: Agent[];\n  let mockOnQuestSelect: ReturnType<typeof vi.fn>;\n  let mockOnQuestComplete: ReturnType<typeof vi.fn>;\n  let mockOnAgentAssign: ReturnType<typeof vi.fn>;\n\n  beforeEach(() => {\n    mockQuests = [\n      {\n        id: 'quest_001',\n        title: 'Debug the Authentication System',\n        description: 'Fix critical authentication bugs affecting user login.',\n        lore: 'The authentication guardians have been compromised...',\n        type: 'main',\n        category: 'Investigation',\n        difficulty: 'Medium',\n        status: 'available',\n        icon: 'üîç',\n        objectives: [\n          {\n            id: 'obj_001_1',\n            description: 'Identify the root cause',\n            completed: false,\n            progress: 0,\n            maxProgress: 1\n          },\n          {\n            id: 'obj_001_2',\n            description: 'Implement the fix',\n            completed: false,\n            progress: 0,\n            maxProgress: 1\n          }\n        ],\n        currentObjectiveIndex: 0,\n        progressPercentage: 0,\n        requirements: {\n          minLevel: 3,\n          requiredSkills: [\n            { skill: 'Debugging', level: 5 }\n          ]\n        },\n        rewards: {\n          xp: 500,\n          gold: 200,\n          items: ['Bug Hunter Badge'],\n          skillPoints: 2\n        },\n        assignedAgents: [],\n        recommendedTeamSize: 2,\n        autoAssign: false,\n        dialogue: [],\n        createdAt: new Date(),\n        repeatable: false,\n        timeLimit: 120\n      },\n      {\n        id: 'quest_002',\n        title: 'Daily Code Review',\n        description: 'Review and improve code quality across projects.',\n        type: 'daily',\n        category: 'Creation',\n        difficulty: 'Easy',\n        status: 'available',\n        icon: 'üìù',\n        objectives: [\n          {\n            id: 'obj_002_1',\n            description: 'Review 5 pull requests',\n            completed: false,\n            progress: 2,\n            maxProgress: 5\n          }\n        ],\n        currentObjectiveIndex: 0,\n        progressPercentage: 40,\n        requirements: {\n          minLevel: 1\n        },\n        rewards: {\n          xp: 150,\n          gold: 50,\n          items: ['Review Token']\n        },\n        assignedAgents: [1],\n        recommendedTeamSize: 1,\n        autoAssign: true,\n        dialogue: [],\n        createdAt: new Date(),\n        repeatable: true,\n        cooldownHours: 24\n      },\n      {\n        id: 'quest_003',\n        title: 'The Epic Raid: System Overhaul',\n        description: 'Complete overhaul of the legacy system architecture.',\n        lore: 'Ancient code spirits guard the legacy systems...',\n        type: 'raid',\n        category: 'Combat',\n        difficulty: 'Legendary',\n        status: 'locked',\n        icon: '‚öîÔ∏è',\n        objectives: [\n          {\n            id: 'obj_003_1',\n            description: 'Analyze legacy architecture',\n            completed: false,\n            progress: 0,\n            maxProgress: 1\n          }\n        ],\n        currentObjectiveIndex: 0,\n        progressPercentage: 0,\n        requirements: {\n          minLevel: 15,\n          teamSize: { min: 4, max: 8 },\n          requiredQuests: ['quest_001']\n        },\n        rewards: {\n          xp: 5000,\n          gold: 2000,\n          items: ['Legendary Architect Crown'],\n          skillPoints: 10\n        },\n        assignedAgents: [],\n        recommendedTeamSize: 6,\n        autoAssign: false,\n        dialogue: [],\n        createdAt: new Date(),\n        repeatable: false\n      }\n    ];\n\n    mockAgents = [\n      {\n        id: 1,\n        name: 'Agent Alpha',\n        class: 'Code Master',\n        level: 8,\n        xp: 1200,\n        xpToNext: 1500,\n        stats: { intelligence: 85, creativity: 70, reliability: 90, speed: 75, leadership: 65 },\n        specializations: ['JavaScript', 'Debugging'],\n        currentMission: 'Available for Mission',\n        personality: 'Analytical',\n        avatar: 'ü§ñ',\n        knowledgeBase: {\n          totalMemories: 150,\n          recentLearning: 'Advanced debugging techniques',\n          knowledgeDomains: {},\n          crawlingProgress: { active: false, lastUrl: '', pagesLearned: 0, knowledgeGained: 0 }\n        },\n        equipment: { primary: 'Debug Tool', secondary: 'Code Scanner', utility: 'Knowledge Base' },\n        relationships: [],\n        skillTree: {},\n        realtimeActivity: []\n      },\n      {\n        id: 2,\n        name: 'Agent Beta',\n        class: 'Data Sage',\n        level: 5,\n        xp: 800,\n        xpToNext: 1000,\n        stats: { intelligence: 95, creativity: 60, reliability: 85, speed: 65, leadership: 55 },\n        specializations: ['Data Analysis', 'Research'],\n        currentMission: 'Researching optimization patterns',\n        personality: 'Thorough',\n        avatar: 'üìä',\n        knowledgeBase: {\n          totalMemories: 200,\n          recentLearning: 'Statistical methods',\n          knowledgeDomains: {},\n          crawlingProgress: { active: false, lastUrl: '', pagesLearned: 0, knowledgeGained: 0 }\n        },\n        equipment: { primary: 'Analysis Engine', secondary: 'Data Probe', utility: 'Research Kit' },\n        relationships: [],\n        skillTree: {},\n        realtimeActivity: []\n      }\n    ];\n\n    mockOnQuestSelect = vi.fn();\n    mockOnQuestComplete = vi.fn();\n    mockOnAgentAssign = vi.fn();\n  });\n\n  describe('Rendering', () => {\n    it('should render quest board with all quests', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('Debug the Authentication System')).toBeInTheDocument();\n      expect(screen.getByText('Daily Code Review')).toBeInTheDocument();\n      expect(screen.getByText('The Epic Raid: System Overhaul')).toBeInTheDocument();\n    });\n\n    it('should render quest difficulties with appropriate styling', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('Medium')).toBeInTheDocument();\n      expect(screen.getByText('Easy')).toBeInTheDocument();\n      expect(screen.getByText('Legendary')).toBeInTheDocument();\n    });\n\n    it('should render quest icons and categories', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('üîç')).toBeInTheDocument();\n      expect(screen.getByText('üìù')).toBeInTheDocument();\n      expect(screen.getByText('‚öîÔ∏è')).toBeInTheDocument();\n      expect(screen.getByText('Investigation')).toBeInTheDocument();\n      expect(screen.getByText('Creation')).toBeInTheDocument();\n      expect(screen.getByText('Combat')).toBeInTheDocument();\n    });\n\n    it('should render quest progress bars', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const progressBars = screen.getAllByRole('progressbar');\n      expect(progressBars.length).toBeGreaterThan(0);\n      \n      // Daily quest has 40% progress\n      const dailyQuestProgress = progressBars.find(bar => \n        bar.getAttribute('aria-valuenow') === '40'\n      );\n      expect(dailyQuestProgress).toBeInTheDocument();\n    });\n  });\n\n  describe('Quest Status Display', () => {\n    it('should show available quests as selectable', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const availableQuests = mockQuests.filter(q => q.status === 'available');\n      availableQuests.forEach(quest => {\n        const questElement = screen.getByText(quest.title).closest('[data-quest-id]');\n        expect(questElement).not.toHaveClass('opacity-50');\n      });\n    });\n\n    it('should show locked quests as disabled', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const lockedQuest = screen.getByText('The Epic Raid: System Overhaul').closest('[data-quest-id]');\n      expect(lockedQuest).toHaveClass('opacity-50');\n    });\n\n    it('should show quest requirements', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('Level 3+')).toBeInTheDocument();\n      expect(screen.getByText('Level 15+')).toBeInTheDocument();\n      expect(screen.getByText('Team: 4-8')).toBeInTheDocument();\n    });\n\n    it('should show assigned agents', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('Agent Alpha')).toBeInTheDocument();\n    });\n\n    it('should show time limits', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('‚è±Ô∏è 120 min')).toBeInTheDocument();\n    });\n  });\n\n  describe('Quest Rewards Display', () => {\n    it('should show XP rewards', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('500 XP')).toBeInTheDocument();\n      expect(screen.getByText('150 XP')).toBeInTheDocument();\n      expect(screen.getByText('5000 XP')).toBeInTheDocument();\n    });\n\n    it('should show gold rewards', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('200 Gold')).toBeInTheDocument();\n      expect(screen.getByText('50 Gold')).toBeInTheDocument();\n      expect(screen.getByText('2000 Gold')).toBeInTheDocument();\n    });\n\n    it('should show item rewards', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText('Bug Hunter Badge')).toBeInTheDocument();\n      expect(screen.getByText('Review Token')).toBeInTheDocument();\n      expect(screen.getByText('Legendary Architect Crown')).toBeInTheDocument();\n    });\n  });\n\n  describe('Filtering and Sorting', () => {\n    it('should filter quests by difficulty', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const difficultyFilter = screen.getByLabelText(/filter by difficulty/i);\n      await user.selectOptions(difficultyFilter, 'Medium');\n\n      expect(screen.getByText('Debug the Authentication System')).toBeInTheDocument();\n      expect(screen.queryByText('Daily Code Review')).not.toBeInTheDocument();\n    });\n\n    it('should filter quests by type', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const typeFilter = screen.getByLabelText(/filter by type/i);\n      await user.selectOptions(typeFilter, 'daily');\n\n      expect(screen.getByText('Daily Code Review')).toBeInTheDocument();\n      expect(screen.queryByText('Debug the Authentication System')).not.toBeInTheDocument();\n    });\n\n    it('should filter quests by status', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const statusFilter = screen.getByLabelText(/filter by status/i);\n      await user.selectOptions(statusFilter, 'locked');\n\n      expect(screen.getByText('The Epic Raid: System Overhaul')).toBeInTheDocument();\n      expect(screen.queryByText('Daily Code Review')).not.toBeInTheDocument();\n    });\n\n    it('should sort quests by XP reward', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const sortSelect = screen.getByLabelText(/sort by/i);\n      await user.selectOptions(sortSelect, 'xp_desc');\n\n      // Should show highest XP first\n      const questElements = screen.getAllByText(/XP/);\n      expect(questElements[0]).toHaveTextContent('5000 XP');\n    });\n  });\n\n  describe('Quest Interaction', () => {\n    it('should call onQuestSelect when quest is clicked', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      await user.click(screen.getByText('Debug the Authentication System'));\n\n      expect(mockOnQuestSelect).toHaveBeenCalledWith(mockQuests[0]);\n    });\n\n    it('should not allow selecting locked quests', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      await user.click(screen.getByText('The Epic Raid: System Overhaul'));\n\n      expect(mockOnQuestSelect).not.toHaveBeenCalled();\n    });\n\n    it('should show agent assignment interface', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const assignButton = screen.getByText('Assign Agents');\n      await user.click(assignButton);\n\n      expect(screen.getByText('Available Agents')).toBeInTheDocument();\n    });\n\n    it('should show quest completion button for assigned quests', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const completeButton = screen.getByText('Complete Quest');\n      expect(completeButton).toBeInTheDocument();\n    });\n  });\n\n  describe('Agent Assignment', () => {\n    it('should show eligible agents for quest', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const assignButton = screen.getByText('Assign Agents');\n      await user.click(assignButton);\n\n      // Agent Alpha should be eligible (level 8 >= required level 3)\n      expect(screen.getByText('Agent Alpha')).toBeInTheDocument();\n    });\n\n    it('should disable ineligible agents', async () => {\n      // Create a high-level quest\n      const highLevelQuest: Quest = {\n        ...mockQuests[0],\n        requirements: { minLevel: 10 }\n      };\n\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={[highLevelQuest]}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const assignButton = screen.getByText('Assign Agents');\n      await user.click(assignButton);\n\n      // Both agents are under level 10, so should be disabled\n      const agentAlpha = screen.getByText('Agent Alpha').closest('button');\n      const agentBeta = screen.getByText('Agent Beta').closest('button');\n      \n      expect(agentAlpha).toBeDisabled();\n      expect(agentBeta).toBeDisabled();\n    });\n\n    it('should show busy agents as unavailable', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const assignButton = screen.getByText('Assign Agents');\n      await user.click(assignButton);\n\n      // Agent Beta is busy with research\n      expect(screen.getByText('Researching optimization patterns')).toBeInTheDocument();\n    });\n\n    it('should call onAgentAssign when agent is assigned', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const assignButton = screen.getByText('Assign Agents');\n      await user.click(assignButton);\n\n      const agentButton = screen.getByText('Agent Alpha').closest('button');\n      await user.click(agentButton!);\n\n      expect(mockOnAgentAssign).toHaveBeenCalledWith(mockQuests[0], mockAgents[0]);\n    });\n  });\n\n  describe('Quest Completion', () => {\n    it('should call onQuestComplete when complete button is clicked', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const completeButton = screen.getByText('Complete Quest');\n      await user.click(completeButton);\n\n      expect(mockOnQuestComplete).toHaveBeenCalled();\n    });\n\n    it('should show completion confirmation dialog', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const completeButton = screen.getByText('Complete Quest');\n      await user.click(completeButton);\n\n      expect(screen.getByText(/are you sure you want to complete/i)).toBeInTheDocument();\n    });\n\n    it('should show expected XP rewards in completion dialog', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const completeButton = screen.getByText('Complete Quest');\n      await user.click(completeButton);\n\n      expect(screen.getByText('150 XP')).toBeInTheDocument(); // Daily quest reward\n    });\n  });\n\n  describe('Empty State', () => {\n    it('should show empty state when no quests available', () => {\n      render(\n        <QuestBoard\n          quests={[]}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByText(/no quests available/i)).toBeInTheDocument();\n    });\n\n    it('should show empty state when all quests are filtered out', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const difficultyFilter = screen.getByLabelText(/filter by difficulty/i);\n      await user.selectOptions(difficultyFilter, 'Expert');\n\n      expect(screen.getByText(/no quests match your filters/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper ARIA labels', () => {\n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      expect(screen.getByRole('main', { name: /quest board/i })).toBeInTheDocument();\n      expect(screen.getByLabelText(/filter by difficulty/i)).toBeInTheDocument();\n    });\n\n    it('should be keyboard navigable', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      await user.tab();\n      expect(screen.getByLabelText(/filter by difficulty/i)).toHaveFocus();\n    });\n\n    it('should announce quest selection to screen readers', async () => {\n      // const user = userEvent.setup(); // unused\n      \n      render(\n        <QuestBoard\n          quests={mockQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const questCard = screen.getByText('Debug the Authentication System').closest('[role=\"button\"]');\n      expect(questCard).toHaveAttribute('aria-describedby');\n    });\n  });\n\n  describe('Performance', () => {\n    it('should handle large numbers of quests efficiently', () => {\n      const manyQuests = Array(100).fill(null).map((_, i) => ({\n        ...mockQuests[0],\n        id: `quest_${i}`,\n        title: `Quest ${i}`\n      }));\n\n      const startTime = performance.now();\n      \n      render(\n        <QuestBoard\n          quests={manyQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      const renderTime = performance.now() - startTime;\n      expect(renderTime).toBeLessThan(1000); // Should render in under 1 second\n    });\n\n    it('should virtualize quest list for large datasets', () => {\n      const manyQuests = Array(1000).fill(null).map((_, i) => ({\n        ...mockQuests[0],\n        id: `quest_${i}`,\n        title: `Quest ${i}`\n      }));\n\n      render(\n        <QuestBoard\n          quests={manyQuests}\n          agents={mockAgents}\n          onQuestSelect={mockOnQuestSelect}\n          onQuestComplete={mockOnQuestComplete}\n          onAgentAssign={mockOnAgentAssign}\n        />\n      );\n\n      // Should not render all 1000 quests at once\n      const renderedQuests = screen.getAllByText(/Quest \\d+/);\n      expect(renderedQuests.length).toBeLessThan(50);\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/e2e/gameFlow.e2e.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userEvent' is defined but never used.","line":4,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockLevelUpEvent' is assigned a value but never used.","line":250,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":250,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'initialLevel' is assigned a value but never used.","line":288,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":288,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'updatedLevel' is assigned a value but never used.","line":299,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":299,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'questCard' is assigned a value but never used.","line":319,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":319,"endColumn":22}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport App from '../../src/App';\n\n// Mock external dependencies\nvi.mock('../../src/hooks/useLevelProgression', () => ({\n  useLevelProgression: () => ({\n    awardXp: vi.fn().mockResolvedValue({ \n      id: 1, \n      name: 'Test Agent', \n      level: 6, \n      xp: 100,\n      xpToNext: 200 \n    }),\n    completeQuest: vi.fn().mockResolvedValue([{\n      id: 1,\n      name: 'Test Agent',\n      level: 6,\n      xp: 600,\n      xpToNext: 800\n    }]),\n    calculatePreviewXp: vi.fn(() => ({\n      newLevel: 6,\n      levelUp: true,\n      xpProgress: 100,\n      xpToNext: 200\n    })),\n    playLevelUpEffect: vi.fn(),\n    activeNotifications: [],\n    levelUpQueue: [],\n    recentEvents: [],\n    isProcessing: false,\n    dismissNotification: vi.fn(),\n    clearDismissedNotifications: vi.fn(),\n    getNextLevelUp: vi.fn(),\n    onLevelUp: vi.fn(),\n    onXpGain: vi.fn(),\n    onSkillUnlock: vi.fn()\n  })\n}));\n\n// Mock requestAnimationFrame for smooth testing\nglobal.requestAnimationFrame = vi.fn((cb) => {\n  setTimeout(cb, 16);\n  return 1;\n});\n\ndescribe('Game Flow End-to-End Tests', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('Application Initialization', () => {\n    it('should load and display the main game interface', async () => {\n      render(<App />);\n\n      // Wait for the app to load\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      // Verify main sections are present\n      expect(screen.getByText(/Agents/i)).toBeInTheDocument();\n      expect(screen.getByText(/Quests/i)).toBeInTheDocument();\n    });\n\n    it('should load initial agents data', async () => {\n      render(<App />);\n\n      await waitFor(() => {\n        // Should show agents from initial data\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n        expect(screen.getByText('Sage Analytica')).toBeInTheDocument();\n        expect(screen.getByText('Bard Creative')).toBeInTheDocument();\n        expect(screen.getByText('Scout Rapid')).toBeInTheDocument();\n      });\n    });\n\n    it('should load initial quests data', async () => {\n      render(<App />);\n\n      await waitFor(() => {\n        // Should show quests from initial data\n        expect(screen.getByText('Welcome to the Guild')).toBeInTheDocument();\n        expect(screen.getByText('The Lost Algorithm')).toBeInTheDocument();\n        expect(screen.getByText('Documentation Patrol')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Agent Management Flow', () => {\n    it('should display agent details when clicking on an agent', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n      });\n\n      // Click on an agent\n      await user.click(screen.getByText('CodeMaster Zyx'));\n\n      // Should show detailed agent information\n      await waitFor(() => {\n        expect(screen.getByText(/Level/)).toBeInTheDocument();\n        expect(screen.getByText(/Intelligence/)).toBeInTheDocument();\n        expect(screen.getByText(/Specializations/)).toBeInTheDocument();\n      });\n    });\n\n    it('should show XP progression information for agents', async () => {\n      render(<App />);\n\n      await waitFor(() => {\n        // Should show XP bars\n        const xpBars = screen.getAllByRole('progressbar');\n        expect(xpBars.length).toBeGreaterThan(0);\n        \n        // Should show XP text\n        expect(screen.getByText(/XP/)).toBeInTheDocument();\n      });\n    });\n\n    it('should handle agent mission assignment', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n      });\n\n      // Look for mission assignment interface\n      const assignButton = screen.queryByText(/Assign Mission/i);\n      if (assignButton) {\n        await user.click(assignButton);\n        \n        // Should show mission assignment interface\n        await waitFor(() => {\n          expect(screen.getByText(/Available Missions|Select Mission/i)).toBeInTheDocument();\n        });\n      }\n    });\n  });\n\n  describe('Quest Management Flow', () => {\n    it('should display quest board with available quests', async () => {\n      render(<App />);\n\n      await waitFor(() => {\n        // Verify quest types are displayed\n        expect(screen.getByText('Welcome to the Guild')).toBeInTheDocument();\n        expect(screen.getByText('The Lost Algorithm')).toBeInTheDocument();\n      });\n\n      // Should show quest difficulties\n      expect(screen.getByText('Tutorial')).toBeInTheDocument();\n      expect(screen.getByText('Medium')).toBeInTheDocument();\n    });\n\n    it('should handle quest selection and details', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Welcome to the Guild')).toBeInTheDocument();\n      });\n\n      // Click on a quest\n      await user.click(screen.getByText('Welcome to the Guild'));\n\n      // Should show quest details\n      await waitFor(() => {\n        expect(screen.getByText(/Report to the Guild Master/)).toBeInTheDocument();\n        expect(screen.getByText(/100.*XP/)).toBeInTheDocument();\n      });\n    });\n\n    it('should show quest objectives and progress', async () => {\n      render(<App />);\n\n      await waitFor(() => {\n        // Should show quest objectives\n        const progressBars = screen.getAllByRole('progressbar');\n        expect(progressBars.length).toBeGreaterThan(0);\n        \n        // Should show completion percentages\n        expect(screen.getByText(/0%|40%|100%/)).toBeInTheDocument();\n      });\n    });\n\n    it('should handle agent assignment to quests', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Welcome to the Guild')).toBeInTheDocument();\n      });\n\n      // Look for quest assignment interface\n      const questCard = screen.getByText('Welcome to the Guild').closest('[data-quest-id]');\n      if (questCard) {\n        const assignButton = questCard.querySelector('button') || \n                           screen.getByRole('button', { name: /assign/i });\n        \n        if (assignButton) {\n          await user.click(assignButton);\n          \n          // Should show agent assignment interface\n          await waitFor(() => {\n            expect(screen.getByText(/Select Agent|Available Agents/i)).toBeInTheDocument();\n          });\n        }\n      }\n    });\n  });\n\n  describe('Level Progression Flow', () => {\n    it('should handle XP award and level up animations', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n      });\n\n      // Trigger level up through quest completion or direct XP award\n      const completeButton = screen.queryByRole('button', { name: /complete|award xp/i });\n      \n      if (completeButton) {\n        await user.click(completeButton);\n\n        // Should trigger level up animation\n        await waitFor(() => {\n          // Check for level up notification or animation\n          const notification = screen.queryByText(/Level Up|Congratulations/i);\n          if (notification) {\n            expect(notification).toBeInTheDocument();\n          }\n        });\n      }\n    });\n\n    it('should show skill unlocks on level up', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      // Mock a level up event with skill unlocks\n      const mockLevelUpEvent = {\n        agentId: 1,\n        oldLevel: 5,\n        newLevel: 6,\n        xpGained: 200,\n        source: 'Quest Completion',\n        unlockedSkills: ['Advanced Analysis', 'Master Coordination'],\n        statIncreases: [\n          { stat: 'intelligence' as const, amount: 2, reason: 'Level Up' }\n        ],\n        timestamp: new Date()\n      };\n\n      // Trigger level up\n      const completeButton = screen.queryByRole('button', { name: /complete/i });\n      \n      if (completeButton) {\n        await user.click(completeButton);\n\n        await waitFor(() => {\n          // Should show skill unlocks if level up occurs\n          const skillText = screen.queryByText(/skill|unlock/i);\n          if (skillText) {\n            expect(skillText).toBeInTheDocument();\n          }\n        });\n      }\n    });\n\n    it('should update agent stats after level up', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n      });\n\n      // Record initial stats\n      const initialLevel = screen.getByText(/Level \\d+/);\n      const initialXP = screen.getByText(/\\d+.*XP/);\n\n      // Trigger XP award/quest completion\n      const actionButton = screen.queryByRole('button', { name: /complete|award/i });\n      \n      if (actionButton) {\n        await user.click(actionButton);\n\n        await waitFor(() => {\n          // Stats should be updated\n          const updatedLevel = screen.getByText(/Level \\d+/);\n          const updatedXP = screen.getByText(/\\d+.*XP/);\n          \n          // At least XP should change\n          expect(updatedXP).not.toEqual(initialXP);\n        });\n      }\n    });\n  });\n\n  describe('Quest Completion Flow', () => {\n    it('should handle complete quest workflow', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Documentation Patrol')).toBeInTheDocument();\n      });\n\n      // Find and complete a quest\n      const questCard = screen.getByText('Documentation Patrol').closest('[data-quest-id]');\n      const completeButton = screen.queryByRole('button', { name: /complete/i });\n      \n      if (completeButton && !completeButton.disabled) {\n        await user.click(completeButton);\n\n        // Should show completion confirmation\n        await waitFor(async () => {\n          const confirmation = screen.queryByText(/complete.*quest|confirm/i);\n          if (confirmation) {\n            expect(confirmation).toBeInTheDocument();\n            \n            // Confirm completion\n            const confirmButton = screen.getByRole('button', { name: /yes|confirm|complete/i });\n            await user.click(confirmButton);\n          }\n        });\n\n        // Should update quest status and award XP\n        await waitFor(() => {\n          // Look for XP award notification or updated agent stats\n          const xpNotification = screen.queryByText(/\\+.*XP|experience gained/i);\n          if (xpNotification) {\n            expect(xpNotification).toBeInTheDocument();\n          }\n        });\n      }\n    });\n\n    it('should show quest rewards upon completion', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('Welcome to the Guild')).toBeInTheDocument();\n      });\n\n      // Complete tutorial quest\n      const tutorialQuest = screen.getByText('Welcome to the Guild');\n      const questCard = tutorialQuest.closest('[data-quest-id]');\n      \n      if (questCard) {\n        const completeButton = questCard.querySelector('button[data-action=\"complete\"]') ||\n                             screen.queryByRole('button', { name: /complete/i });\n        \n        if (completeButton) {\n          await user.click(completeButton);\n\n          await waitFor(() => {\n            // Should show rewards (XP, gold, items)\n            expect(screen.getByText(/100.*XP/)).toBeInTheDocument();\n            expect(screen.getByText(/50.*Gold/)).toBeInTheDocument();\n            expect(screen.getByText(/Apprentice Badge/)).toBeInTheDocument();\n          });\n        }\n      }\n    });\n\n    it('should handle team quest completion with multiple agents', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('The Lost Algorithm')).toBeInTheDocument();\n      });\n\n      // This quest requires multiple agents\n      const teamQuest = screen.getByText('The Lost Algorithm');\n      const questCard = teamQuest.closest('[data-quest-id]');\n      \n      if (questCard) {\n        // Should show team requirements\n        expect(screen.getByText(/team.*3|3.*agents/i)).toBeInTheDocument();\n        \n        // Assign multiple agents\n        const assignButton = screen.queryByRole('button', { name: /assign/i });\n        if (assignButton) {\n          await user.click(assignButton);\n          \n          await waitFor(() => {\n            // Should show agent selection interface\n            const agentButtons = screen.getAllByText(/CodeMaster|Sage|Bard|Scout/);\n            expect(agentButtons.length).toBeGreaterThan(0);\n            \n            // Select multiple agents\n            if (agentButtons.length >= 2) {\n              await user.click(agentButtons[0]);\n              await user.click(agentButtons[1]);\n            }\n          });\n        }\n      }\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle network errors gracefully', async () => {\n      // Mock network failure\n      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n      \n      render(<App />);\n\n      // App should still render\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      consoleSpy.mockRestore();\n    });\n\n    it('should handle invalid agent data gracefully', async () => {\n      render(<App />);\n\n      // Even with potential data issues, app should render\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      // Should not crash the application\n      expect(() => {\n        fireEvent.click(document.body);\n      }).not.toThrow();\n    });\n\n    it('should handle rapid user interactions', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n      });\n\n      // Rapidly click on different elements\n      const elements = screen.getAllByRole('button').slice(0, 5);\n      \n      for (const element of elements) {\n        await user.click(element);\n      }\n\n      // App should remain stable\n      expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('Responsive Design and Accessibility', () => {\n    it('should be keyboard navigable', async () => {\n      // const user = userEvent.setup(); // unused\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      // Tab through interactive elements\n      await user.tab();\n      expect(document.activeElement).toBeInstanceOf(HTMLElement);\n      \n      await user.tab();\n      expect(document.activeElement).toBeInstanceOf(HTMLElement);\n      \n      // Should be able to activate focused elements with Enter\n      await user.keyboard('{Enter}');\n      \n      // App should remain functional\n      expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n    });\n\n    it('should have proper ARIA labels and roles', async () => {\n      render(<App />);\n\n      await waitFor(() => {\n        // Check for main application structure\n        expect(screen.getByRole('main')).toBeInTheDocument();\n        \n        // Check for navigation elements\n        const navigation = screen.queryByRole('navigation');\n        if (navigation) {\n          expect(navigation).toBeInTheDocument();\n        }\n\n        // Check for proper button labels\n        const buttons = screen.getAllByRole('button');\n        buttons.forEach(button => {\n          expect(button).toHaveAttribute('aria-label');\n        });\n      });\n    });\n\n    it('should adapt to different screen sizes', async () => {\n      // Mock different viewport sizes\n      Object.defineProperty(window, 'innerWidth', {\n        writable: true,\n        configurable: true,\n        value: 768,\n      });\n      Object.defineProperty(window, 'innerHeight', {\n        writable: true,\n        configurable: true,\n        value: 1024,\n      });\n\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      // Should render mobile-friendly layout\n      const mainContent = screen.getByRole('main');\n      expect(mainContent).toBeInTheDocument();\n\n      // Test tablet size\n      Object.defineProperty(window, 'innerWidth', { value: 1024 });\n      fireEvent(window, new Event('resize'));\n\n      // Should still be functional\n      expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('Performance and Memory', () => {\n    it('should handle large numbers of agents efficiently', async () => {\n      const startTime = performance.now();\n      \n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      const renderTime = performance.now() - startTime;\n      \n      // Should render quickly even with multiple agents and quests\n      expect(renderTime).toBeLessThan(2000); // Under 2 seconds\n    });\n\n    it('should not have memory leaks in animations', async () => {\n      const { unmount } = render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      // Trigger some animations\n      const buttons = screen.getAllByRole('button').slice(0, 3);\n      for (const button of buttons) {\n        fireEvent.click(button);\n      }\n\n      // Unmount should not throw errors\n      expect(() => unmount()).not.toThrow();\n    });\n  });\n\n  describe('Data Persistence', () => {\n    it('should maintain state during component updates', async () => {\n      const { rerender } = render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n      });\n\n      // Rerender the component\n      rerender(<App />);\n\n      // State should be maintained\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n        expect(screen.getByText('Welcome to the Guild')).toBeInTheDocument();\n      });\n    });\n\n    it('should handle browser refresh gracefully', async () => {\n      render(<App />);\n\n      await waitFor(() => {\n        expect(screen.getByText(/Agent RPG/i)).toBeInTheDocument();\n      });\n\n      // Simulate page refresh by re-rendering\n      const { rerender } = render(<App />);\n      rerender(<App />);\n\n      // Should reload with initial data\n      await waitFor(() => {\n        expect(screen.getByText('CodeMaster Zyx')).toBeInTheDocument();\n        expect(screen.getByText('Welcome to the Guild')).toBeInTheDocument();\n      });\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/hooks/useLevelProgression.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/integration/levelProgression.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/performance/xpCalculation.performance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/smoke.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/test-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/utils/levelProgression.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/tests/utils/xpCalculator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/vite.config.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/yogi/agent-rpg-project/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]