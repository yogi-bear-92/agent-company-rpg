name: Deployment Pipeline

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  pre-deployment:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      should_deploy: ${{ steps.determine-env.outputs.should_deploy }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Get version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          else
            echo "version=dev-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          fi
      
      - name: Check deployment prerequisites
        if: steps.determine-env.outputs.should_deploy == 'true'
        run: |
          echo "Deploying to: ${{ steps.determine-env.outputs.environment }}"
          echo "Version: ${{ steps.version.outputs.version }}"
          
          # Check if this commit has passed CI
          if [[ "${{ github.event.inputs.force_deploy }}" != "true" ]]; then
            echo "Checking CI status..."
            # This would typically check the CI status via GitHub API
            echo "CI checks passed (simulated)"
          fi
  
  build-and-publish:
    name: Build & Publish Container
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should_deploy == 'true'
    
    permissions:
      contents: read
      packages: write
    
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Create Dockerfile if not exists
        run: |
          if [ ! -f "Dockerfile" ]; then
            cat > Dockerfile << 'EOF'
          FROM node:20-alpine AS builder
          
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci --only=production && npm cache clean --force
          
          COPY . .
          RUN npm run build
          
          FROM nginx:alpine AS production
          
          # Copy built assets from builder stage
          COPY --from=builder /app/dist /usr/share/nginx/html
          
          # Copy nginx configuration
          RUN echo 'server { \
              listen 80; \
              location / { \
                  root /usr/share/nginx/html; \
                  index index.html index.htm; \
                  try_files \$uri \$uri/ /index.html; \
              } \
              location /health { \
                  access_log off; \
                  return 200 "healthy\n"; \
                  add_header Content-Type text/plain; \
              } \
          }' > /etc/nginx/conf.d/default.conf
          
          EXPOSE 80
          CMD ["nginx", "-g", "daemon off;"]
          EOF
            echo "Created Dockerfile for static site deployment"
          fi
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Output image details
        id: image
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.version }}" >> $GITHUB_OUTPUT
  
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pre-deployment, build-and-publish]
    if: needs.pre-deployment.outputs.environment == 'staging'
    
    environment:
      name: staging
      url: https://staging.agent-rpg.com
    
    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying ${{ needs.build-and-publish.outputs.image }} to staging environment"
          
          # Simulate deployment (replace with actual deployment logic)
          echo "Deployment steps:"
          echo "1. Pull image: ${{ needs.build-and-publish.outputs.image }}"
          echo "2. Update staging environment"
          echo "3. Run health checks"
          echo "4. Update load balancer"
          
          # Example with kubectl (if using Kubernetes)
          # kubectl set image deployment/agent-rpg agent-rpg=${{ needs.build-and-publish.outputs.image }} -n staging
          # kubectl rollout status deployment/agent-rpg -n staging --timeout=300s
          
          echo "Staging deployment completed successfully"
      
      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging environment..."
          
          # Example smoke tests
          curl -f https://staging.agent-rpg.com/health || exit 1
          
          # Add more comprehensive smoke tests here
          echo "Smoke tests passed"
      
      - name: Notify staging deployment
        run: |
          npx claude-flow@alpha hooks notify --message "Staging deployment completed for version ${{ needs.pre-deployment.outputs.version }}"
  
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [pre-deployment, build-and-publish]
    if: needs.pre-deployment.outputs.environment == 'production'
    
    environment:
      name: production
      url: https://agent-rpg.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Production deployment
        run: |
          echo "Deploying ${{ needs.build-and-publish.outputs.image }} to production environment"
          
          # Blue-green deployment simulation
          echo "Starting blue-green deployment:"
          echo "1. Deploy to green environment"
          echo "2. Run comprehensive health checks"
          echo "3. Switch traffic to green"
          echo "4. Monitor metrics"
          echo "5. Keep blue as rollback option"
          
          # Example with more comprehensive deployment
          # ./scripts/deploy-production.sh ${{ needs.build-and-publish.outputs.image }}
          
          echo "Production deployment completed successfully"
      
      - name: Run production health checks
        run: |
          echo "Running production health checks..."
          
          # Comprehensive health checks
          curl -f https://agent-rpg.com/health || exit 1
          curl -f https://agent-rpg.com/api/health || exit 1
          
          # Check critical functionality
          echo "All production health checks passed"
      
      - name: Update deployment status
        run: |
          echo "## ðŸš€ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.pre-deployment.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ needs.build-and-publish.outputs.image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: https://agent-rpg.com" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Post-deployment Actions" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Container built and published" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Deployed to production" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Health checks passed" >> $GITHUB_STEP_SUMMARY
          echo "- [ ] Monitor metrics for 24 hours" >> $GITHUB_STEP_SUMMARY
      
      - name: Notify production deployment
        run: |
          npx claude-flow@alpha hooks notify --message "Production deployment completed successfully for version ${{ needs.pre-deployment.outputs.version }}"
  
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    needs: [pre-deployment, deploy-staging, deploy-production]
    
    steps:
      - name: Rollback deployment
        run: |
          echo "Deployment failed, initiating rollback..."
          
          # Rollback logic here
          echo "1. Identify last successful deployment"
          echo "2. Switch traffic back to stable version"
          echo "3. Clean up failed deployment artifacts"
          echo "4. Notify team of rollback"
          
          # Example rollback command
          # kubectl rollout undo deployment/agent-rpg -n production
      
      - name: Notify rollback
        run: |
          npx claude-flow@alpha hooks notify --message "Deployment failed and rollback initiated for ${{ github.sha }}"
