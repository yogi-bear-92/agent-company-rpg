{"version":3,"file":"utils-Bub4qm0q.js","sources":["../../src/utils/xpCalculator.ts","../../src/utils/levelProgression.ts"],"sourcesContent":["// XP calculation and level progression utilities for Agent Company RPG\n\nimport { Agent, AgentStats } from '../types/agent';\nimport { Quest } from '../types/quest';\n\n// XP multipliers and constants\nconst BASE_XP_TO_NEXT_LEVEL = 100;\nconst LEVEL_XP_MULTIPLIER = 1.5;\nconst DIFFICULTY_MULTIPLIERS = {\n  Tutorial: 0.5,\n  Easy: 1.0,\n  Medium: 1.5,\n  Hard: 2.0,\n  Expert: 3.0,\n  Legendary: 5.0\n};\n\nconst CLASS_XP_BONUSES = {\n  'Code Master': { Investigation: 1.2, Creation: 1.3 },\n  'Data Sage': { Investigation: 1.3, Exploration: 1.2 },\n  'Creative Bard': { Creation: 1.3, Diplomacy: 1.2 },\n  'Rapid Scout': { Exploration: 1.3, Combat: 1.2 },\n  'System Architect': { Creation: 1.2, Training: 1.3 },\n  'Bug Hunter': { Investigation: 1.3, Combat: 1.3 },\n  'Documentation Wizard': { Creation: 1.2, Diplomacy: 1.3 }\n};\n\n// Calculate XP required for next level\nexport function calculateXpToNextLevel(level: number): number {\n  return Math.floor(BASE_XP_TO_NEXT_LEVEL * Math.pow(LEVEL_XP_MULTIPLIER, level - 1));\n}\n\n// Calculate total XP from level 1 to target level\nexport function calculateTotalXpForLevel(targetLevel: number): number {\n  let totalXp = 0;\n  for (let level = 1; level < targetLevel; level++) {\n    totalXp += calculateXpToNextLevel(level);\n  }\n  return totalXp;\n}\n\n// Calculate level from total XP\nexport function calculateLevelFromXp(totalXp: number): { level: number; currentLevelXp: number; xpToNext: number } {\n  let level = 1;\n  let remainingXp = totalXp;\n  \n  while (remainingXp >= calculateXpToNextLevel(level)) {\n    remainingXp -= calculateXpToNextLevel(level);\n    level++;\n  }\n  \n  return {\n    level,\n    currentLevelXp: remainingXp,\n    xpToNext: calculateXpToNextLevel(level)\n  };\n}\n\n// Calculate XP reward for completing a quest\nexport function calculateQuestXpReward(\n  quest: Quest,\n  agent: Agent,\n  completionTime?: number, // in minutes\n  optionalObjectivesCompleted: number = 0\n): number {\n  let xpReward = quest.rewards.xp;\n  \n  // Apply difficulty multiplier\n  xpReward *= DIFFICULTY_MULTIPLIERS[quest.difficulty] || 1.0;\n  \n  // Apply class bonus if applicable\n  const classBonus = CLASS_XP_BONUSES[agent.class as keyof typeof CLASS_XP_BONUSES];\n  if (classBonus && classBonus[quest.category as keyof typeof classBonus]) {\n    xpReward *= classBonus[quest.category as keyof typeof classBonus];\n  }\n  \n  // Time bonus (complete faster than expected)\n  if (completionTime && quest.timeLimit) {\n    const timeRatio = completionTime / quest.timeLimit;\n    if (timeRatio < 0.5) {\n      xpReward *= 1.5; // 50% bonus for completing in half the time\n    } else if (timeRatio < 0.75) {\n      xpReward *= 1.25; // 25% bonus for completing in 3/4 time\n    } else if (timeRatio < 1.0) {\n      xpReward *= 1.1; // 10% bonus for beating the timer\n    }\n  }\n  \n  // Optional objectives bonus\n  const totalOptionalObjectives = quest.objectives.filter(obj => obj.optional).length;\n  if (totalOptionalObjectives > 0 && optionalObjectivesCompleted > 0) {\n    const optionalRatio = optionalObjectivesCompleted / totalOptionalObjectives;\n    xpReward += (quest.bonusRewards?.xp || 0) * optionalRatio;\n  }\n  \n  // Team synergy bonus (if multiple agents)\n  if (quest.assignedAgents.length > 1) {\n    const synergyBonus = 1 + (quest.assignedAgents.length - 1) * 0.05; // 5% per additional agent\n    xpReward *= Math.min(synergyBonus, 1.25); // Cap at 25% bonus\n  }\n  \n  // Streak bonus (if agent has been completing quests consistently)\n  const streakBonus = calculateStreakBonus(agent);\n  xpReward *= streakBonus;\n  \n  return Math.floor(xpReward);\n}\n\n// Calculate XP for partial quest completion\nexport function calculatePartialQuestXp(\n  quest: Quest,\n  completedObjectives: number,\n  totalObjectives: number\n): number {\n  const completionRatio = completedObjectives / totalObjectives;\n  return Math.floor(quest.rewards.xp * completionRatio * 0.5); // 50% efficiency for partial completion\n}\n\n// Calculate streak bonus based on recent activity\nexport function calculateStreakBonus(agent: Agent): number {\n  const recentActivity = agent.realtimeActivity.filter(\n    activity => activity.xpGained && activity.xpGained > 0\n  );\n  \n  if (recentActivity.length >= 10) return 1.3; // 30% bonus for hot streak\n  if (recentActivity.length >= 5) return 1.15; // 15% bonus for good streak\n  if (recentActivity.length >= 3) return 1.05; // 5% bonus for starting streak\n  return 1.0; // No streak bonus\n}\n\n// Calculate XP from skill usage\nexport function calculateSkillXp(\n  skillLevel: number,\n  usageComplexity: 'simple' | 'moderate' | 'complex' = 'moderate'\n): number {\n  const complexityMultipliers = {\n    simple: 0.5,\n    moderate: 1.0,\n    complex: 2.0\n  };\n  \n  const baseXp = 10;\n  const levelBonus = skillLevel * 2;\n  const complexityMultiplier = complexityMultipliers[usageComplexity];\n  \n  return Math.floor(baseXp * complexityMultiplier + levelBonus);\n}\n\n// Calculate XP from collaboration\nexport function calculateCollaborationXp(\n  participantCount: number,\n  taskComplexity: 'low' | 'medium' | 'high',\n  successRate: number // 0-1\n): number {\n  const complexityBase = {\n    low: 20,\n    medium: 50,\n    high: 100\n  };\n  \n  const baseXp = complexityBase[taskComplexity];\n  const teamBonus = Math.log2(participantCount + 1) * 10; // Logarithmic scaling for team size\n  const successMultiplier = 0.5 + (successRate * 0.5); // 50-100% based on success\n  \n  return Math.floor((baseXp + teamBonus) * successMultiplier);\n}\n\n// Calculate XP from knowledge acquisition\nexport function calculateKnowledgeXp(\n  knowledgeItems: number,\n  domainExpertise: number, // 0-100\n  isNewDomain: boolean\n): number {\n  const baseXpPerItem = 5;\n  const expertiseMultiplier = 1 + (domainExpertise / 100); // 1x to 2x based on expertise\n  const newDomainBonus = isNewDomain ? 50 : 0;\n  \n  return Math.floor(knowledgeItems * baseXpPerItem * expertiseMultiplier + newDomainBonus);\n}\n\n// Apply XP to agent and handle level up\nexport function applyXpToAgent(\n  agent: Agent,\n  xpGained: number,\n  source: string\n): {\n  updatedAgent: Agent;\n  leveledUp: boolean;\n  newLevel?: number;\n  unlockedSkills?: string[];\n} {\n  const totalXp = agent.xp + xpGained;\n  const currentLevelData = calculateLevelFromXp(totalXp);\n  \n  const leveledUp = currentLevelData.level > agent.level;\n  const updatedAgent: Agent = {\n    ...agent,\n    xp: currentLevelData.currentLevelXp,\n    xpToNext: currentLevelData.xpToNext,\n    level: currentLevelData.level,\n    realtimeActivity: [\n      {\n        timestamp: new Date().toISOString(),\n        action: source,\n        xpGained: xpGained\n      },\n      ...agent.realtimeActivity.slice(0, 49) // Keep last 50 activities\n    ]\n  };\n  \n  // Handle level up bonuses\n  if (leveledUp) {\n    updatedAgent.stats = applyLevelUpStatBonus(updatedAgent.stats, currentLevelData.level);\n    const unlockedSkills = getUnlockedSkillsForLevel(currentLevelData.level, agent.class);\n    \n    return {\n      updatedAgent,\n      leveledUp: true,\n      newLevel: currentLevelData.level,\n      unlockedSkills\n    };\n  }\n  \n  return {\n    updatedAgent,\n    leveledUp: false\n  };\n}\n\n// Apply stat bonuses on level up\nfunction applyLevelUpStatBonus(stats: AgentStats, newLevel: number): AgentStats {\n  const statBonus = Math.floor(newLevel / 5) + 1; // +1 to all stats every 5 levels, minimum +1\n  \n  return {\n    intelligence: stats.intelligence + statBonus,\n    creativity: stats.creativity + statBonus,\n    reliability: stats.reliability + statBonus,\n    speed: stats.speed + statBonus,\n    leadership: stats.leadership + statBonus\n  };\n}\n\n// Get newly unlocked skills for a level\nfunction getUnlockedSkillsForLevel(level: number, agentClass: string): string[] {\n  const unlockedSkills: string[] = [];\n  \n  // Universal skills unlocked at certain levels\n  if (level === 5) unlockedSkills.push('Advanced Analysis');\n  if (level === 10) unlockedSkills.push('Master Coordination');\n  if (level === 15) unlockedSkills.push('Expert Optimization');\n  if (level === 20) unlockedSkills.push('Legendary Insight');\n  \n  // Class-specific skills\n  const classSkills: { [key: string]: { [level: number]: string } } = {\n    'Code Master': {\n      3: 'Refactoring Mastery',\n      7: 'Architecture Vision',\n      12: 'Performance Tuning',\n      18: 'System Integration'\n    },\n    'Data Sage': {\n      3: 'Pattern Recognition',\n      7: 'Predictive Analysis',\n      12: 'Data Synthesis',\n      18: 'Knowledge Fusion'\n    },\n    'Creative Bard': {\n      3: 'Narrative Weaving',\n      7: 'Design Harmony',\n      12: 'Innovation Spark',\n      18: 'Creative Revolution'\n    },\n    'Rapid Scout': {\n      3: 'Quick Navigation',\n      7: 'Parallel Processing',\n      12: 'Speed Optimization',\n      18: 'Instant Deployment'\n    }\n  };\n  \n  const classSpecificSkills = classSkills[agentClass];\n  if (classSpecificSkills && classSpecificSkills[level]) {\n    unlockedSkills.push(classSpecificSkills[level]);\n  }\n  \n  return unlockedSkills;\n}\n\n// Calculate team XP distribution\nexport function distributeTeamXp(\n  totalXp: number,\n  agents: Agent[],\n  contributionWeights?: { [agentId: number]: number }\n): { [agentId: number]: number } {\n  const distribution: { [agentId: number]: number } = {};\n  \n  if (!contributionWeights) {\n    // Equal distribution\n    const xpPerAgent = Math.floor(totalXp / agents.length);\n    agents.forEach(agent => {\n      distribution[agent.id] = xpPerAgent;\n    });\n  } else {\n    // Weighted distribution\n    const totalWeight = Object.values(contributionWeights).reduce((sum, weight) => sum + weight, 0);\n    agents.forEach(agent => {\n      const weight = contributionWeights[agent.id] || 1;\n      distribution[agent.id] = Math.floor(totalXp * (weight / totalWeight));\n    });\n  }\n  \n  return distribution;\n}\n\n// XP decay for inactive agents\nexport function calculateXpDecay(\n  lastActivityDate: Date,\n  currentDate: Date = new Date()\n): number {\n  const daysSinceActivity = (currentDate.getTime() - lastActivityDate.getTime()) / (1000 * 60 * 60 * 24);\n  \n  if (daysSinceActivity <= 7) return 0; // No decay for first week\n  if (daysSinceActivity <= 14) return 0.05; // 5% decay for second week\n  if (daysSinceActivity <= 30) return 0.1; // 10% decay for first month\n  if (daysSinceActivity <= 60) return 0.2; // 20% decay for second month\n  return 0.3; // 30% max decay\n}\n\nexport default {\n  calculateXpToNextLevel,\n  calculateTotalXpForLevel,\n  calculateLevelFromXp,\n  calculateQuestXpReward,\n  calculatePartialQuestXp,\n  calculateStreakBonus,\n  calculateSkillXp,\n  calculateCollaborationXp,\n  calculateKnowledgeXp,\n  applyXpToAgent,\n  distributeTeamXp,\n  calculateXpDecay\n};","// Level progression system for Agent Company RPG\n// Integrates with existing XP calculator and provides progression mechanics\n\nimport { Agent } from '../types/agent';\nimport { Quest } from '../types/quest';\nimport { \n  applyXpToAgent, \n  calculateQuestXpReward\n} from './xpCalculator';\n\nexport interface LevelUpEvent {\n  agentId: number;\n  oldLevel: number;\n  newLevel: number;\n  xpGained: number;\n  source: string;\n  unlockedSkills: string[];\n  statIncreases: StatIncrease[];\n  timestamp: Date;\n}\n\nexport interface StatIncrease {\n  stat: keyof Agent['stats'];\n  amount: number;\n  reason: string;\n}\n\nexport interface ProgressionEvent {\n  type: 'xp_gained' | 'level_up' | 'skill_unlocked' | 'quest_completed';\n  agentId: number;\n  data: unknown;\n  timestamp: Date;\n}\n\nexport interface ProgressionNotification {\n  id: string;\n  type: 'level_up' | 'skill_unlock' | 'achievement' | 'stat_boost';\n  title: string;\n  message: string;\n  icon: string;\n  priority: 'low' | 'medium' | 'high';\n  duration?: number; // milliseconds to show\n  actions?: Array<{\n    label: string;\n    action: () => void;\n  }>;\n  timestamp: Date;\n  dismissed: boolean;\n}\n\nexport interface ProgressionState {\n  recentEvents: ProgressionEvent[];\n  activeNotifications: ProgressionNotification[];\n  levelUpQueue: LevelUpEvent[];\n  isProcessing: boolean;\n}\n\n// Core level progression manager\nexport class LevelProgressionManager {\n  private progressionState: ProgressionState = {\n    recentEvents: [],\n    activeNotifications: [],\n    levelUpQueue: [],\n    isProcessing: false\n  };\n\n  private eventHandlers: { [key: string]: ((event: ProgressionEvent) => void)[] } = {};\n\n  constructor() {\n    this.setupEventHandlers();\n  }\n\n  // Subscribe to progression events\n  on(eventType: string, handler: (event: ProgressionEvent) => void) {\n    if (!this.eventHandlers[eventType]) {\n      this.eventHandlers[eventType] = [];\n    }\n    this.eventHandlers[eventType].push(handler);\n  }\n\n  // Emit progression events\n  private emit(event: ProgressionEvent) {\n    const handlers = this.eventHandlers[event.type];\n    if (handlers) {\n      handlers.forEach(handler => handler(event));\n    }\n    \n    // Store recent events\n    this.progressionState.recentEvents.unshift(event);\n    if (this.progressionState.recentEvents.length > 100) {\n      this.progressionState.recentEvents = this.progressionState.recentEvents.slice(0, 100);\n    }\n  }\n\n  // Process XP gain and handle level ups\n  async processXpGain(\n    agent: Agent, \n    xpAmount: number, \n    source: string\n  ): Promise<{\n    updatedAgent: Agent;\n    levelUpEvent?: LevelUpEvent;\n    notifications: ProgressionNotification[];\n  }> {\n    this.progressionState.isProcessing = true;\n\n    try {\n      // Apply XP using existing calculator\n      const result = applyXpToAgent(agent, xpAmount, source);\n      \n      let levelUpEvent: LevelUpEvent | undefined;\n      const notifications: ProgressionNotification[] = [];\n\n      // Emit XP gained event\n      this.emit({\n        type: 'xp_gained',\n        agentId: agent.id,\n        data: { amount: xpAmount, source, newTotal: result.updatedAgent.xp },\n        timestamp: new Date()\n      });\n\n      // Handle level up\n      if (result.leveledUp && result.newLevel) {\n        levelUpEvent = {\n          agentId: agent.id,\n          oldLevel: agent.level,\n          newLevel: result.newLevel,\n          xpGained: xpAmount,\n          source,\n          unlockedSkills: result.unlockedSkills || [],\n          statIncreases: this.calculateStatIncreases(agent.level, result.newLevel),\n          timestamp: new Date()\n        };\n\n        // Queue level up for animations\n        this.progressionState.levelUpQueue.push(levelUpEvent);\n\n        // Create level up notification\n        notifications.push(this.createLevelUpNotification(levelUpEvent));\n\n        // Create skill unlock notifications\n        if (result.unlockedSkills) {\n          result.unlockedSkills.forEach(skill => {\n            notifications.push(this.createSkillUnlockNotification(agent, skill));\n          });\n        }\n\n        // Emit level up event\n        this.emit({\n          type: 'level_up',\n          agentId: agent.id,\n          data: levelUpEvent,\n          timestamp: new Date()\n        });\n      }\n\n      // Add notifications to active queue\n      notifications.forEach(notification => {\n        this.progressionState.activeNotifications.push(notification);\n      });\n\n      return {\n        updatedAgent: result.updatedAgent,\n        levelUpEvent,\n        notifications\n      };\n    } finally {\n      this.progressionState.isProcessing = false;\n    }\n  }\n\n  // Process quest completion with full progression\n  async processQuestCompletion(\n    quest: Quest,\n    agents: Agent[],\n    completionData?: {\n      completionTime?: number;\n      optionalObjectivesCompleted?: number;\n      teamPerformanceBonus?: number;\n    }\n  ): Promise<{\n    updatedAgents: Agent[];\n    levelUpEvents: LevelUpEvent[];\n    notifications: ProgressionNotification[];\n  }> {\n    const updatedAgents: Agent[] = [];\n    const levelUpEvents: LevelUpEvent[] = [];\n    const allNotifications: ProgressionNotification[] = [];\n\n    for (const agent of agents) {\n      if (quest.assignedAgents.includes(agent.id)) {\n        // Calculate XP reward for this agent\n        const xpReward = calculateQuestXpReward(\n          quest, \n          agent, \n          completionData?.completionTime,\n          completionData?.optionalObjectivesCompleted\n        );\n\n        // Apply team performance bonus\n        const finalXp = completionData?.teamPerformanceBonus \n          ? Math.floor(xpReward * completionData.teamPerformanceBonus)\n          : xpReward;\n\n        // Process XP gain\n        const result = await this.processXpGain(\n          agent, \n          finalXp, \n          `Quest: ${quest.title}`\n        );\n\n        updatedAgents.push(result.updatedAgent);\n        if (result.levelUpEvent) {\n          levelUpEvents.push(result.levelUpEvent);\n        }\n        allNotifications.push(...result.notifications);\n      } else {\n        updatedAgents.push(agent);\n      }\n    }\n\n    // Emit quest completion event\n    this.emit({\n      type: 'quest_completed',\n      agentId: 0, // System event\n      data: { quest, agents: quest.assignedAgents, xpAwarded: true },\n      timestamp: new Date()\n    });\n\n    return {\n      updatedAgents,\n      levelUpEvents,\n      notifications: allNotifications\n    };\n  }\n\n  // Calculate stat increases between levels\n  private calculateStatIncreases(oldLevel: number, newLevel: number): StatIncrease[] {\n    const increases: StatIncrease[] = [];\n    \n    // Major milestone bonuses\n    if (newLevel >= 5 && oldLevel < 5) {\n      increases.push({\n        stat: 'intelligence',\n        amount: 2,\n        reason: 'Novice Milestone'\n      });\n    }\n    \n    if (newLevel >= 10 && oldLevel < 10) {\n      increases.push({\n        stat: 'creativity',\n        amount: 3,\n        reason: 'Adept Milestone'\n      });\n      increases.push({\n        stat: 'leadership',\n        amount: 2,\n        reason: 'Leadership Awakening'\n      });\n    }\n\n    if (newLevel >= 15 && oldLevel < 15) {\n      increases.push({\n        stat: 'reliability',\n        amount: 3,\n        reason: 'Expert Milestone'\n      });\n    }\n\n    if (newLevel >= 20 && oldLevel < 20) {\n      increases.push({\n        stat: 'speed',\n        amount: 4,\n        reason: 'Master Milestone'\n      });\n      increases.push({\n        stat: 'intelligence',\n        amount: 3,\n        reason: 'Wisdom of Masters'\n      });\n    }\n\n    return increases;\n  }\n\n  // Create level up notification\n  private createLevelUpNotification(levelUpEvent: LevelUpEvent): ProgressionNotification {\n    return {\n      id: `levelup_${levelUpEvent.agentId}_${Date.now()}`,\n      type: 'level_up',\n      title: `Level Up! ðŸŽ‰`,\n      message: `Agent reached Level ${levelUpEvent.newLevel}!`,\n      icon: 'â¬†ï¸',\n      priority: 'high',\n      duration: 5000,\n      timestamp: new Date(),\n      dismissed: false\n    };\n  }\n\n  // Create skill unlock notification\n  private createSkillUnlockNotification(agent: Agent, skill: string): ProgressionNotification {\n    return {\n      id: `skill_${agent.id}_${skill}_${Date.now()}`,\n      type: 'skill_unlock',\n      title: `New Skill Unlocked! âœ¨`,\n      message: `${agent.name} learned \"${skill}\"`,\n      icon: 'ðŸ”“',\n      priority: 'medium',\n      duration: 4000,\n      timestamp: new Date(),\n      dismissed: false\n    };\n  }\n\n  // Get progression state\n  getProgressionState(): ProgressionState {\n    return { ...this.progressionState };\n  }\n\n  // Dismiss notification\n  dismissNotification(notificationId: string) {\n    const notification = this.progressionState.activeNotifications.find(n => n.id === notificationId);\n    if (notification) {\n      notification.dismissed = true;\n    }\n  }\n\n  // Clear dismissed notifications\n  clearDismissedNotifications() {\n    this.progressionState.activeNotifications = this.progressionState.activeNotifications\n      .filter(n => !n.dismissed);\n  }\n\n  // Get next level up event from queue\n  getNextLevelUpEvent(): LevelUpEvent | undefined {\n    return this.progressionState.levelUpQueue.shift();\n  }\n\n  // Setup default event handlers\n  private setupEventHandlers() {\n    // Auto-clear old events\n    setInterval(() => {\n      const cutoff = new Date();\n      cutoff.setHours(cutoff.getHours() - 24);\n      \n      this.progressionState.recentEvents = this.progressionState.recentEvents\n        .filter(event => event.timestamp > cutoff);\n      \n      this.clearDismissedNotifications();\n    }, 60000); // Every minute\n  }\n}\n\n// Global instance\nexport const levelProgressionManager = new LevelProgressionManager();\n\n// Helper functions for external use\nexport function createProgressionManager(): LevelProgressionManager {\n  return new LevelProgressionManager();\n}\n\nexport function processAgentXpGain(\n  agent: Agent, \n  xpAmount: number, \n  source: string\n): Promise<{\n  updatedAgent: Agent;\n  levelUpEvent?: LevelUpEvent;\n  notifications: ProgressionNotification[];\n}> {\n  return levelProgressionManager.processXpGain(agent, xpAmount, source);\n}\n\nexport function processQuestCompletion(\n  quest: Quest,\n  agents: Agent[],\n  completionData?: {\n    completionTime?: number;\n    optionalObjectivesCompleted?: number;\n    teamPerformanceBonus?: number;\n  }\n): Promise<{\n  updatedAgents: Agent[];\n  levelUpEvents: LevelUpEvent[];\n  notifications: ProgressionNotification[];\n}> {\n  return levelProgressionManager.processQuestCompletion(quest, agents, completionData);\n}\n\n// Animation and visual helpers\nexport function generateLevelUpAnimation(levelUpEvent: LevelUpEvent) {\n  return {\n    agentId: levelUpEvent.agentId,\n    animations: [\n      {\n        type: 'scale',\n        from: 1,\n        to: 1.2,\n        duration: 300,\n        easing: 'ease-out'\n      },\n      {\n        type: 'glow',\n        color: '#ffd700',\n        intensity: 0.8,\n        duration: 2000\n      },\n      {\n        type: 'particles',\n        count: 20,\n        colors: ['#ffd700', '#ffed4e', '#f7c41f'],\n        duration: 1500\n      }\n    ]\n  };\n}\n\nexport default levelProgressionManager;"],"names":["DIFFICULTY_MULTIPLIERS","Tutorial","Easy","Medium","Hard","Expert","Legendary","CLASS_XP_BONUSES","Investigation","Creation","Exploration","Diplomacy","Combat","Training","calculateXpToNextLevel","level","Math","floor","pow","calculateQuestXpReward","quest","agent","completionTime","optionalObjectivesCompleted","xpReward","rewards","xp","difficulty","classBonus","class","category","timeLimit","timeRatio","totalOptionalObjectives","objectives","filter","obj","optional","length","optionalRatio","bonusRewards","assignedAgents","synergyBonus","min","streakBonus","recentActivity","realtimeActivity","activity","xpGained","calculateStreakBonus","applyXpToAgent","source","currentLevelData","totalXp","remainingXp","currentLevelXp","xpToNext","calculateLevelFromXp","leveledUp","updatedAgent","timestamp","Date","toISOString","action","slice","stats","newLevel","statBonus","intelligence","creativity","reliability","speed","leadership","applyLevelUpStatBonus","unlockedSkills","agentClass","push","classSpecificSkills","getUnlockedSkillsForLevel","levelProgressionManager","constructor","__publicField","this","recentEvents","activeNotifications","levelUpQueue","isProcessing","setupEventHandlers","on","eventType","handler","eventHandlers","emit","event","handlers","type","forEach","progressionState","unshift","processXpGain","xpAmount","result","levelUpEvent","notifications","agentId","id","data","amount","newTotal","oldLevel","statIncreases","calculateStatIncreases","createLevelUpNotification","skill","createSkillUnlockNotification","notification","processQuestCompletion","agents","completionData","updatedAgents","levelUpEvents","allNotifications","includes","finalXp","teamPerformanceBonus","title","xpAwarded","increases","stat","reason","now","message","icon","priority","duration","dismissed","name","getProgressionState","dismissNotification","notificationId","find","n","clearDismissedNotifications","getNextLevelUpEvent","shift","setInterval","cutoff","setHours","getHours","processAgentXpGain"],"mappings":"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"}